/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/pages/units/worker.ts":
/*!***********************************!*\
  !*** ./src/pages/units/worker.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var types_gameEngine_gameEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/gameEngine */ \"./src/types/gameEngine/gameEngine.ts\");\n/* harmony import */ var types_gameEngine_characters_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! types/gameEngine/characters/index */ \"./src/types/gameEngine/characters/index.ts\");\n/* harmony import */ var types_gameEngine_characterScripts_charactersList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! types/gameEngine/characterScripts/charactersList */ \"./src/types/gameEngine/characterScripts/charactersList.ts\");\n\n\n\nonmessage = (e) => {\n    const { playerList, opponentList, playerName, opponentName, simulationCount, } = e.data;\n    const ctx = self;\n    const engine = new types_gameEngine_gameEngine__WEBPACK_IMPORTED_MODULE_0__.Engine();\n    const playerCharacters = playerList.map((unit) => {\n        const characterClass = types_gameEngine_characterScripts_charactersList__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(unit.id);\n        if (characterClass) {\n            return new characterClass(unit, playerName, unit.isLeader, engine);\n        }\n        else {\n            return new types_gameEngine_characters_index__WEBPACK_IMPORTED_MODULE_1__.Character(unit, playerName, unit.isLeader, engine);\n        }\n    });\n    const opponentCharacters = opponentList.map((unit) => {\n        const characterClass = types_gameEngine_characterScripts_charactersList__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(unit.id);\n        if (characterClass) {\n            return new characterClass(unit, opponentName, unit.isLeader, engine);\n        }\n        else {\n            return new types_gameEngine_characters_index__WEBPACK_IMPORTED_MODULE_1__.Character(unit, opponentName, unit.isLeader, engine);\n        }\n    });\n    const results = engine.startSimulation(playerCharacters, opponentCharacters, Math.min(simulationCount, 10));\n    console.log(results);\n    ctx.postMessage(results);\n};\n\n\n//# sourceURL=webpack://swgoh/./src/pages/units/worker.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/C3POCHEWBACCA.ts":
/*!****************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/C3POCHEWBACCA.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n/* harmony import */ var _characters_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../characters/utils */ \"./src/types/gameEngine/characters/utils.ts\");\n/* harmony import */ var _characters_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../characters/index */ \"./src/types/gameEngine/characters/index.ts\");\n\n\n\n\nclass basicskill_C3POCHEWBACCA extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_C3POCHEWBACCA\", \"Frantic Shot\", `Deal Physical damage to target enemy and inflict Evasion Down for 2 turns.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                if (!this.checkEvade(\"physical\", primaryTarget)) {\n                    this.dealDamage(\"physical\", primaryTarget, 2, 5, stats, canBeCountered);\n                    this._character.statusEffect.inflictDebuff([\n                        {\n                            name: \"Evasion Down\",\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(),\n                            duration: 2,\n                            sourceAbility: this,\n                        },\n                    ], primaryTarget, 1, this);\n                }\n            }\n        });\n    }\n}\nclass specialskill_C3POCHEWBACCA01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_C3POCHEWBACCA01\", \"Shining Distraction\", `Dispel all debuffs on Threepio & Chewie. Rebel allies recover 15% Protection and gain Advantage for 2 turns. Dispel all buffs from all enemies and Blind them for 2 turns. This ability can't be evaded.`, character);\n        this.cooldown = 2;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            this._character.statusEffect.removeDebuff(\"all\", undefined, this);\n            const rebelAllies = this._character.teammates.filter((ally) => ally.hasTags(\"Rebel\", this._character.id));\n            rebelAllies.forEach((target) => {\n                target.heal({\n                    healthType: \"protection\",\n                    amount: 0.15,\n                    amountType: \"multiplicative\",\n                }, this);\n                target.statusEffect.addBuff([{ name: \"Advantage\", duration: 2, id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), sourceAbility: this }], 1, this);\n            });\n            this._character.opponents.forEach((target) => {\n                target.statusEffect.removeBuff(\"all\", this._character, this);\n                this._character.statusEffect.inflictDebuff([{ name: \"Blind\", duration: 2, id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), sourceAbility: this }], target, 1, this);\n            });\n        });\n    }\n}\nclass specialskill_C3POCHEWBACCA02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_C3POCHEWBACCA02\", \"Chewie's Rage\", `Deal Physical damage to all enemies. Deal damage an additional time (up to 5 additional times) for each enemy that has been defeated during the battle. Threepio & Chewie gain 10% Offense (stacking) until the end of battle whenever this ability defeats an enemy.`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            const deadOpponents = this._character.opponents.filter((c) => c.isDead);\n            let defeatedByAbility = 0;\n            this._character.opponents.forEach((target) => {\n                if (!this.checkEvade(\"physical\", target)) {\n                    for (let i = 0; i < deadOpponents.length + 1; i++) {\n                        //custom logic instead of the standard dealDamage method\n                        const { offense, critChance, armorPen } = this._character.stats.getCombatStats(\"physical\", stats);\n                        const varianceOffense = offense * (1 - (0,_characters_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0 - 5, 5) / 100);\n                        const { isCrit, damageTotal } = target.receiveDamage(\"physical\", varianceOffense * 2, armorPen, critChance, this._character.stats.critDamage, stats);\n                        this._character.gameEngine.addLogs([\n                            {\n                                targetLogData: target.getLogs(),\n                                damage: {\n                                    amount: damageTotal,\n                                    isCrit,\n                                },\n                            },\n                        ]);\n                        this._character?.checkDeath(target);\n                        if (target.isDead) {\n                            defeatedByAbility++;\n                        }\n                        this._character.dispatchEvent(\"dealDamage\", {\n                            damageAmount: damageTotal,\n                            isCrit,\n                            damageType: \"physical\",\n                            target,\n                        });\n                        target.dispatchEvent(\"receiveDamage\", {\n                            damageAmount: damageTotal,\n                            isCrit,\n                            damageType: \"physical\",\n                            attackSource: this.id,\n                        });\n                        target.counterAttack(this._character, i === 0 ? canBeCountered : false);\n                    }\n                }\n            });\n            for (let i = 0; i < defeatedByAbility; i++) {\n                this._character.stats.addTempStats([\n                    {\n                        statToModify: \"physicalOffense\",\n                        modifiedType: \"multiplicative\",\n                        amount: 0.1,\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"specialOffense\",\n                        modifiedType: \"multiplicative\",\n                        amount: 0.1,\n                        characterSourceId: this._character.uniqueId,\n                    },\n                ], this);\n            }\n        });\n    }\n}\nclass uniqueskill_C3POCHEWBACCA extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_C3POCHEWBACCA\", \"I Must Tell The Others\", `If the allied Leader is a non-Galactic Legend Rebel, Threepio & Chewie gain 40% of the Leader's Max Health, Max Protection, Offense, Defense, Potency, and Tenacity at the start of the first encounter, and Rebel allies gain half that amount. Rebel allies have +15% Critical Avoidance.\\n\\nWhenever another Rebel ally uses an ability, Threepio & Chewie are called to assist, dealing 30% less damage (limit once per turn). If they were defeated, Threepio & Chewie are revived with 50% Health and Protection whenever another Rebel ally is revived.\\n\\nWhile enemies are Blinded, they have -50% Tenacity and can't attack out of turn.`, character);\n    }\n    activate() {\n        const teamLeader = this._character.teammates.find((c) => c.isLeader);\n        const otherRebels = this._character.teammates.filter((ally) => {\n            return (!ally.isSelf(this._character) &&\n                ally.hasTags(\"Rebel\", this._character.id));\n        });\n        let triggerCount = 0;\n        if (teamLeader &&\n            (0,_characters_index__WEBPACK_IMPORTED_MODULE_2__.anyTagsMatch)(teamLeader, [\"Rebel & !Galactic Legend\"], teamLeader.id)) {\n            this._character.stats.addTempStats([\n                {\n                    statToModify: \"maxHealth\",\n                    amount: 0.4 * teamLeader.stats.baseStats.maxHealth,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"maxProtection\",\n                    amount: 0.4 * teamLeader.stats.baseStats.maxProtection,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"physicalOffense\",\n                    amount: 0.4 * teamLeader.stats.baseStats.physical.offense,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"specialOffense\",\n                    amount: 0.4 * teamLeader.stats.baseStats.special.offense,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"physicalArmor\",\n                    amount: 0.4 * teamLeader.stats.baseStats.physical.armor,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"specialArmor\",\n                    amount: 0.4 * teamLeader.stats.baseStats.special.armor,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"potency\",\n                    amount: 0.4 * teamLeader.stats.baseStats.potency,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"tenacity\",\n                    amount: 0.4 * teamLeader.stats.baseStats.tenacity,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"physicalCritAvoid\",\n                    amount: 0.15,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"specialCritAvoid\",\n                    amount: 0.15,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n            ], this);\n            this._character.stats.initialize();\n            otherRebels.forEach((character) => {\n                character.stats.addTempStats([\n                    {\n                        statToModify: \"maxHealth\",\n                        amount: 0.2 * teamLeader.stats.baseStats.maxHealth,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"maxProtection\",\n                        amount: 0.2 * teamLeader.stats.baseStats.maxProtection,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"physicalOffense\",\n                        amount: 0.2 * teamLeader.stats.baseStats.physical.offense,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"specialOffense\",\n                        amount: 0.2 * teamLeader.stats.baseStats.special.offense,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"physicalArmor\",\n                        amount: 0.2 * teamLeader.stats.baseStats.physical.armor,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"specialArmor\",\n                        amount: 0.2 * teamLeader.stats.baseStats.special.armor,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"potency\",\n                        amount: 0.2 * teamLeader.stats.baseStats.potency,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"tenacity\",\n                        amount: 0.2 * teamLeader.stats.baseStats.tenacity,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"physicalCritAvoid\",\n                        amount: 0.15,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                    {\n                        statToModify: \"specialCritAvoid\",\n                        amount: 0.15,\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                    },\n                ], this);\n                character.stats.initialize();\n            });\n        }\n        otherRebels.forEach((target) => {\n            target.events.push({\n                eventType: \"useAbility\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ target: opponent }) => {\n                    if (triggerCount < 1) {\n                        triggerCount++;\n                        this._character.assist([\n                            {\n                                statToModify: \"physicalOffense\",\n                                amount: 0.7,\n                                modifiedType: \"multiplicative\",\n                            },\n                            {\n                                statToModify: \"specialOffense\",\n                                amount: 0.7,\n                                modifiedType: \"multiplicative\",\n                            },\n                        ], opponent, this);\n                    }\n                },\n            }, {\n                eventType: \"revive\",\n                characterSourceId: this._character.uniqueId,\n                callback: () => {\n                    if (this._character.isDead) {\n                        this._character.revive(this._character.stats.maxProtection * 0.5, this._character.stats.maxHealth * 0.5);\n                    }\n                },\n            });\n        });\n        this._character.opponents.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    statToModify: \"tenacity\",\n                    amount: -0.5,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return target.statusEffect.hasDebuff(\"Blind\");\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n            ], this);\n            target.statusEffect.addImmune(this._character.uniqueId, \"Assisting\", () => {\n                return target.statusEffect.hasDebuff(\"Blind\");\n            }, this);\n            target.statusEffect.addImmune(this._character.uniqueId, \"CounterAttacking\", () => {\n                return target.statusEffect.hasDebuff(\"Blind\");\n            }, this);\n        });\n        this._character.events.push({\n            characterSourceId: this._character.uniqueId,\n            eventType: \"endOfTurn\",\n            callback: () => {\n                triggerCount = 0;\n            },\n        });\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_C3POCHEWBACCA\", basicskill_C3POCHEWBACCA],\n]);\nconst specialAbilities = new Map([\n    [\"specialskill_C3POCHEWBACCA01\", specialskill_C3POCHEWBACCA01],\n    [\"specialskill_C3POCHEWBACCA02\", specialskill_C3POCHEWBACCA02],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueskill_C3POCHEWBACCA\", uniqueskill_C3POCHEWBACCA],\n]);\nconst leaderAbility = new Map([]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/C3POCHEWBACCA.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/C3POLEGENDARY.ts":
/*!****************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/C3POLEGENDARY.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n/* harmony import */ var _characters_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../characters/index */ \"./src/types/gameEngine/characters/index.ts\");\n\n\n\nclass basicskill_C3POLEGENDARY extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_C3POLEGENDARY\", \"Baffling Trick\", `C-3PO inflicts the unique debuff Confuse for 3 turns (max 3 stacks, can't be evaded or copied). If target is already Confused, duration of their stacks resets to 3 turns. Reduce target's Turn Meter by 6% and 3% more for each stack of Translation on C-3PO. (See Protocol Droid for Translation.)\\n\\nConfuse - Detrimental effects build based on the cumulative number of stacks:\\n1: Cannot gain buffs\\n2: Cannot counter, assist, or gain bonus Turn Meter (Raid bosses and Galactic Legends: -30% Counter Chance)\\n3: When this character uses their Basic ability, increase their cooldowns by 1, which can't be resisted (Raid bosses and Galactic Legends: -50% Defense, doesn't stack with Defense Down)`, character);\n    }\n    execute(targetCharacter, stats) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, false, () => {\n            if (primaryTarget) {\n                primaryTarget.statusEffect.resetDuration(\"Confuse\", 3, \"debuff\");\n                if (primaryTarget.statusEffect.debuffs.filter((d) => d.name === \"Confuse\")\n                    .length < 3) {\n                    this._character.statusEffect.inflictDebuff([\n                        {\n                            name: \"Confuse\",\n                            duration: 3,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            unique: true,\n                            isStackable: true,\n                            sourceAbility: this,\n                        },\n                    ], primaryTarget, 1, this, 3);\n                }\n                const translationCount = this._character.statusEffect.buffs.filter((b) => b.name === \"Translation\").length;\n                primaryTarget.changeTurnMeter(-6 + translationCount * -3, this, this._character);\n            }\n            const protocolDroidAbility = this._character.uniqueAbilities.find((x) => x.id === \"uniqueskill_C3POLEGENDARY01\");\n            //todo, if tech is present, dont do the following\n            this._character.teammates.forEach((ally) => {\n                if (ally.statusEffect.hasBuff(\"Translation\", undefined, 3)) {\n                    ally.specialAbilities.forEach((ability) => {\n                        ability.changeCooldown(-1, protocolDroidAbility ?? this, this._character);\n                    });\n                }\n            });\n        });\n    }\n}\nclass specialskill_C3POLEGENDARY01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialability_C3POLEGENDARY01\", \"Oh My Goodness!\", `C-3PO gains Potency Up and Stealth for 2 turns, then he and target other ally gain Translation for 3 turns. C-3PO inflicts Confuse twice on target enemy for 3 turns, then calls all other allies with Translation to assist, dealing 50% less damage.\\n\\n(See Protocol Droid for a description of Translation.)`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats) {\n        const primaryEnemy = this.findRandomEnemy(targetCharacter);\n        const primaryAlly = this.findRandomAlly(targetCharacter);\n        super.execute(primaryEnemy, stats, false, () => {\n            this._character.statusEffect.addBuff([\n                { name: \"Potency Up\", id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), duration: 2, sourceAbility: this },\n                { name: \"Stealth\", id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), duration: 2, sourceAbility: this },\n                {\n                    name: \"Translation\",\n                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                    duration: 3,\n                    unique: true,\n                    isStackable: true,\n                    sourceAbility: this,\n                },\n            ], 1, this);\n            if (primaryAlly) {\n                primaryAlly.statusEffect.addBuff([\n                    {\n                        name: \"Translation\",\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        duration: 3,\n                        unique: true,\n                        isStackable: true,\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n            }\n            const allTranslationAllies = this._character.teammates.filter((ally) => {\n                return (!ally.isSelf(this._character) &&\n                    ally.statusEffect.hasBuff(\"Translation\"));\n            });\n            if (primaryEnemy) {\n                this._character.statusEffect.inflictDebuff([\n                    {\n                        name: \"Confuse\",\n                        duration: 3,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        unique: true,\n                        isStackable: true,\n                        sourceAbility: this,\n                    },\n                    {\n                        name: \"Confuse\",\n                        duration: 3,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        unique: true,\n                        isStackable: true,\n                        sourceAbility: this,\n                    },\n                ], primaryEnemy, 1, this, 3);\n                allTranslationAllies.forEach((target) => {\n                    target.assist([\n                        {\n                            statToModify: \"physicalOffense\",\n                            modifiedType: \"multiplicative\",\n                            amount: 0.5,\n                        },\n                        {\n                            statToModify: \"specialOffense\",\n                            modifiedType: \"multiplicative\",\n                            amount: 0.5,\n                        },\n                    ], primaryEnemy ?? targetCharacter, this);\n                });\n            }\n        });\n    }\n}\nclass uniqueskill_C3POLEGENDARY01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_C3POLEGENDARY01\", \"Protocol Droid\", `C-3PO has +20 Speed. While C-3PO is active, Galactic Republic, Rebel, Resistance, and Ewok allies gain Translation for 3 turns (max 3 stacks) each time they use a Special ability. Translation cannot be copied. If the character already has Translation, the duration for all current stacks on that character resets to 3 turns. If all allies that can apply Translation are defeated, all stacks of Translation expire.\\n\\nTranslation - Beneficial effects build based on the cumulative number of stacks:\\n1: Gain +30% Max Health\\n2: Gain +15% Critical Chance\\n3: If only one ally who grants Translation is present, decrease this character's cooldowns by 1 when that ally uses their Basic ability (limit once per turn)`, character);\n    }\n    activate() {\n        this._character?.stats.addTempStats([\n            {\n                statToModify: \"speed\",\n                amount: 20,\n                modifiedType: \"additive\",\n            },\n        ], this);\n        const rebelAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Rebel & !Self\"], this._character.id));\n        const resistanceAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Resistance & !Self\"], this._character.id));\n        const ewokAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Ewok & !Self\"], this._character.id));\n        [\n            this._character,\n            ...rebelAllies,\n            ...resistanceAllies,\n            ...ewokAllies,\n        ].forEach((ally) => {\n            ally.events.push({\n                eventType: \"useAbility\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ abilityId }) => {\n                    if (abilityId !== ally.basicAbility?.id) {\n                        ally.statusEffect.resetDuration(\"Translation\", 3, \"buff\", this);\n                        ally.statusEffect.addBuff([\n                            {\n                                name: \"Translation\",\n                                duration: 3,\n                                isStackable: true,\n                                unique: true,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                sourceAbility: this,\n                            },\n                        ], 1, this, 3);\n                    }\n                },\n            });\n        });\n        this._character.events.push({\n            eventType: \"death\",\n            characterSourceId: this._character.uniqueId,\n            callback: () => {\n                const allyTech = this._character.teammates.find((x) => x.id === \"TECH\"); //todo\n                if (allyTech) {\n                }\n                this._character.teammates.forEach((ally) => {\n                    ally.statusEffect.removeBuff(\"Translation\", this._character, this);\n                });\n            },\n        });\n    }\n}\nclass uniqueskill_C3POLEGENDARY02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_C3POLEGENDARY02\", \"Wait For Me!\", `C-3PO and R2-D2 have +10% Evasion for each of their own stacks of Translation. At the start of encounter, C-3PO and R2-D2 gain Translation for 3 turns. When there are no other allied combatants, C-3PO escapes from battle.`, character);\n    }\n    activate() {\n        const validTargets = this._character.teammates.filter((x) => x.id === \"R2D2LEGENDARY\" || x.id === this._character.id);\n        validTargets.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"physicalDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\");\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"physicalDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"physicalDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"specialDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\");\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"specialDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    modifiedType: \"additive\",\n                    statToModify: \"specialDodge\",\n                    amount: 0.1,\n                    condition: () => {\n                        return target.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                    characterSourceId: this._character.uniqueId,\n                },\n            ]);\n            target.events.push({\n                eventType: \"matchSetup\",\n                characterSourceId: this._character.uniqueId,\n                callback: () => {\n                    target.statusEffect.addBuff({\n                        name: \"Translation\",\n                        duration: 3,\n                        unique: true,\n                        isStackable: true,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        sourceAbility: this,\n                    }, 1, this, 3);\n                    target.stats.gainHealth(Infinity, \"health\");\n                },\n            });\n        });\n        [...this._character.teammates, ...this._character.opponents].forEach((ally) => {\n            if (!ally.isSelf(this._character)) {\n                ally.events.push({\n                    eventType: \"startOfTurn\",\n                    characterSourceId: this._character.uniqueId,\n                    callback: () => {\n                        //todo check other passive characters\n                        const aliveAllies = this._character.teammates.filter((x) => !x.isDead);\n                        if (aliveAllies.length === 1 && !this._character.isDead) {\n                            this._character.stats.loseHealth(this._character.stats.maxHealth, \"health\");\n                            this._character.gameEngine.addLogs({\n                                characterLogData: this._character.getLogs(),\n                                customMessage: \"escaped from the battle\",\n                                ability: { source: this.sanitize() },\n                            });\n                        }\n                    },\n                });\n            }\n        });\n    }\n}\nclass uniqueskill_C3POLEGENDARY03 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_C3POLEGENDARY03\", \"Intermediary\", `All allies have +10% Defense Penetration. Each time a Galactic Republic or Ewok ally gains a different, non-unique, non-Protection buff, they gain 15% Protection Up for 2 turns (does not stack with itself). For each stack of Translation, Galactic Republic have +10% Defense Penetration, doubled for Ewoks.`, character);\n    }\n    activate() {\n        this._character.teammates.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                },\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                },\n            ], this);\n        });\n        const ewokAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Ewok\"], this._character.id));\n        const republicAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Galactic Republic\"], this._character.id));\n        [...ewokAllies, ...republicAllies].forEach((ally) => {\n            ally.events.push({\n                eventType: \"buffed\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ buff }) => {\n                    if (!ally.statusEffect.hasBuff(buff.name, undefined, undefined, false) &&\n                        buff.name !== \"Protection Up\" &&\n                        !buff.unique) {\n                        ally.statusEffect.addBuff([\n                            {\n                                name: \"Protection Up\",\n                                duration: 1,\n                                value: 0.15 * ally.stats.maxHealth,\n                                id: \"uniqueskill_C3POLEGENDARY03_ProtectionUp\",\n                                sourceAbility: this,\n                            },\n                        ], 1, this);\n                    }\n                },\n            });\n        });\n        ewokAllies.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n            ], this);\n        });\n        republicAllies.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"specialArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n            ], this);\n        });\n    }\n}\nclass uniqueskill_C3POLEGENDARY04 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_C3POLEGENDARY04\", \"Fretful Mediator\", `All allies have +10% Critical Damage. Whenever a Resistance or Ewok ally uses their Special ability, they inflict Offense Down on the target enemy for 2 turns which cannot be evaded. For each stack of Translation, Resistance allies have +10% Critical Damage, doubled for Ewoks.`, character);\n    }\n    activate() {\n        this._character.teammates.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.1,\n                    modifiedType: \"additive\",\n                },\n            ], this);\n        });\n        const ewokAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Ewok\"], this._character.id));\n        const resistanceAllies = this._character.teammates.filter((ally) => (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Resistance\"], this._character.id));\n        [...ewokAllies, ...resistanceAllies].forEach((ally) => {\n            ally.events.push({\n                eventType: \"useAbility\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ abilityId, target, }) => {\n                    if (ally.specialAbilities.some((x) => x.id === abilityId)) {\n                        ally.statusEffect.inflictDebuff([\n                            {\n                                name: \"Offense Down\",\n                                duration: 2,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                sourceAbility: this,\n                            },\n                        ], target, 1, this);\n                    }\n                },\n            });\n        });\n        ewokAllies.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.2,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.2,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.2,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n            ], this);\n        });\n        resistanceAllies.forEach((ally) => {\n            ally.stats.addTempStats([\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.1,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\");\n                    },\n                },\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.1,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 2);\n                    },\n                },\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.1,\n                    modifiedType: \"additive\",\n                    condition: () => {\n                        return ally.statusEffect.hasBuff(\"Translation\", undefined, 3);\n                    },\n                },\n            ], this);\n        });\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_C3POLEGENDARY\", basicskill_C3POLEGENDARY],\n]);\nconst specialAbilities = new Map([\n    [\"specialskill_C3POLEGENDARY01\", specialskill_C3POLEGENDARY01],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueskill_C3POLEGENDARY01\", uniqueskill_C3POLEGENDARY01],\n    [\"uniqueskill_C3POLEGENDARY02\", uniqueskill_C3POLEGENDARY02],\n    [\"uniqueskill_C3POLEGENDARY03\", uniqueskill_C3POLEGENDARY03],\n    [\"uniqueskill_C3POLEGENDARY04\", uniqueskill_C3POLEGENDARY04],\n]);\nconst leaderAbility = new Map([]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/C3POLEGENDARY.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/CHEWBACCALEGENDARY.ts":
/*!*********************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/CHEWBACCALEGENDARY.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n\n\nclass basicskill_CHEWBACCALEGENDARY extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_CHEWBACCALEGENDARY\", \"Overcharged Shot\", `Deal Physical damage to target enemy and inflict Tenacity Down for 2 turns.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                if (!this.checkEvade(\"physical\", primaryTarget)) {\n                    this.dealDamage(\"physical\", primaryTarget, 1.4, 5, stats, canBeCountered);\n                    this._character.statusEffect.inflictDebuff([\n                        {\n                            name: \"Tenacity Down\",\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                            duration: 2,\n                            sourceAbility: this,\n                        },\n                    ], primaryTarget, 1, this);\n                }\n            }\n        });\n    }\n}\nclass specialskill_CHEWBACCALEGENDARY01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_CHEWBACCALEGENDARY01\", \"Pulverize\", `Dispel all buffs on all enemies, then deal Physical damage to all enemies. Chewbacca gains Offense Up and Critical Chance Up for 2 turns. This attack ignores Defense.`, character);\n        this.cooldown = 4;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            const damagedCharacters = [];\n            this._character.opponents.forEach((target) => {\n                if (!this.checkEvade(\"physical\", target)) {\n                    target.statusEffect.removeBuff(\"all\", this._character, this);\n                    this.dealDamage(\"physical\", target, 0.9, 5, [\n                        {\n                            statToModify: \"physicalArmorPen\",\n                            amount: Infinity,\n                            modifiedType: \"additive\",\n                        },\n                    ], false);\n                    if (canBeCountered) {\n                        damagedCharacters.push(target);\n                    }\n                }\n            });\n            this._character.statusEffect.addBuff([\n                { name: \"Offense Up\", duration: 2, id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), sourceAbility: this },\n                {\n                    name: \"Critical Chance Up\",\n                    duration: 2,\n                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                    sourceAbility: this,\n                },\n            ], 1, this);\n            damagedCharacters.forEach((character) => {\n                character.counterAttack(this._character, canBeCountered);\n            });\n        });\n    }\n}\nclass specialskill_CHEWBACCALEGENDARY02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_CHEWBACCALEGENDARY02\", \"Furious Bowcaster\", `Deal Physical damage to target enemy and Stun them for 1 turn. Then, if the target has no Protection, reset Pulverize's ability cooldown. This attack can't be Evaded.`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                this._character.statusEffect.inflictDebuff([{ name: \"Stun\", duration: 1, id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), sourceAbility: this }], primaryTarget, 1, this);\n                this.dealDamage(\"physical\", primaryTarget, 2.4, 5, [], canBeCountered);\n                if (primaryTarget.stats.protection <= 0) {\n                    this._character.activeAbilities.forEach((ability) => {\n                        if (ability.id === \"specialskill_CHEWBACCALEGENDARY01\") {\n                            ability.changeCooldown(-Infinity, this);\n                        }\n                    });\n                }\n            }\n        });\n    }\n}\nclass uniqueskill_CHEWBACCALEGENDARY01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_CHEWBACCALEGENDARY01\", \"Loyal Friend\", `At the start of the battle, grant Guard to the weakest ally and Han Solo until Chewbacca is defeated. Chewbacca Assists when a Guarded ally uses any ability during their turn, doing 20% less damage, limited once per turn. When Chewbacca deals damage to an enemy, Chewbacca and all Guarded allies recover 3% Health and 3% Protection.\\n\\nGuard: Can't be Critically Hit, immune to Daze and Stun, +25% Critical Chance`, character);\n    }\n    activate() {\n        let triggerCount = 0;\n        this._character?.events.push({\n            characterSourceId: this._character.uniqueId,\n            eventType: \"matchSetup\",\n            callback: () => {\n                const hansolo = this._character.teammates.find((c) => c.id === \"HANSOLO\");\n                const weakestCharacter = this._character.teammates.reduce((weakestCharacter, ally) => {\n                    if (this._character.isSelf(ally)) {\n                        return weakestCharacter;\n                    }\n                    else if (ally.id === \"HANSOLO\") {\n                        return weakestCharacter;\n                    }\n                    else if (!weakestCharacter) {\n                        return ally;\n                    }\n                    else if (ally.stats.health + ally.stats.protection <\n                        weakestCharacter.stats.health +\n                            weakestCharacter.stats.protection) {\n                        return ally;\n                    }\n                    return weakestCharacter;\n                }, null);\n                [weakestCharacter, hansolo].forEach((target) => {\n                    if (target) {\n                        target.statusEffect.addStatusEffect({\n                            name: \"Guard\",\n                            duration: Infinity,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                            sourceAbility: this,\n                        }, this);\n                        target.events.push({\n                            eventType: \"useAbility\",\n                            characterSourceId: this._character.uniqueId,\n                            callback: ({ target }) => {\n                                if (triggerCount < 1) {\n                                    triggerCount++;\n                                    this._character.assist([\n                                        {\n                                            statToModify: \"physicalOffense\",\n                                            amount: 0.8,\n                                            modifiedType: \"multiplicative\",\n                                        },\n                                        {\n                                            statToModify: \"specialOffense\",\n                                            amount: 0.8,\n                                            modifiedType: \"multiplicative\",\n                                        },\n                                    ], target, this);\n                                }\n                            },\n                        });\n                    }\n                });\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"endOfTurn\",\n            callback: () => {\n                triggerCount = 0;\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"dealDamage\",\n            callback: () => {\n                const targetList = this._character.teammates.filter((ally) => {\n                    return (ally.isSelf(this._character) ||\n                        ally.statusEffect.hasStatusEffect(\"Guard\"));\n                });\n                targetList.forEach((target) => {\n                    target.heal({\n                        healthType: \"protection\",\n                        amount: 0.03,\n                        amountType: \"multiplicative\",\n                    }, this);\n                    target.heal({\n                        healthType: \"health\",\n                        amount: 0.03,\n                        amountType: \"multiplicative\",\n                    }, this);\n                });\n            },\n        });\n    }\n    deactivate() {\n        super.deactivate();\n        const targetList = this._character.teammates.filter((ally) => ally.statusEffect.hasStatusEffect(\"Guard\"));\n        targetList.forEach((target) => {\n            target.statusEffect.removeStatusEffect(\"Guard\", this, this._character);\n        });\n    }\n}\nclass uniqueskill_CHEWBACCALEGENDARY02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_CHEWBACCALEGENDARY02\", \"Raging Wookie\", `Chewbacca is immune to Ability Block and Cooldown Increase. When Chewbacca deals damage to an enemy with an attack, he deals bonus damage equal to 20% of their Max Health. When Chewbacca takes damage from an attack, he gains +25% Offense and +25% Critical Chance until the end of his next turn. When Chewbacca or a Guarded ally takes damage from an attack, reduce Furious Bowcaster's cooldown by 1.`, character);\n    }\n    activate() {\n        let triggers = [];\n        this._character.statusEffect.addImmune(this._character.uniqueId, \"Ability Block\");\n        this._character.statusEffect.addImmune(this._character.uniqueId, \"Cooldown Increase\");\n        this._character.events.push({\n            eventType: \"dealDamage\",\n            characterSourceId: this._character.uniqueId,\n            callback: ({ target }) => {\n                const alreadyTriggered = triggers.some((t) => t === target.uniqueId);\n                if (!alreadyTriggered) {\n                    triggers.push(target.uniqueId);\n                    this.dealDamage(\"true\", target, target.stats.maxHealth * 0.2, 0, [], false, this);\n                }\n            },\n        }, {\n            eventType: \"receiveDamage\",\n            characterSourceId: this._character.uniqueId,\n            callback: ({ attackSource }) => {\n                if (attackSource) {\n                    this._character.stats.addTempStats([\n                        {\n                            statToModify: \"physicalOffense\",\n                            amount: 0.25,\n                            modifiedType: \"multiplicative\",\n                            expires: {\n                                count: 1,\n                                frequency: \"turn\",\n                            },\n                        },\n                        {\n                            statToModify: \"specialOffense\",\n                            amount: 0.25,\n                            modifiedType: \"multiplicative\",\n                            expires: {\n                                count: 1,\n                                frequency: \"turn\",\n                            },\n                        },\n                        {\n                            statToModify: \"physicalCritChance\",\n                            amount: 0.25,\n                            modifiedType: \"additive\",\n                            expires: {\n                                count: 1,\n                                frequency: \"turn\",\n                            },\n                        },\n                        {\n                            statToModify: \"specialCritChance\",\n                            amount: 0.25,\n                            modifiedType: \"additive\",\n                            expires: {\n                                count: 1,\n                                frequency: \"turn\",\n                            },\n                        },\n                    ], this);\n                }\n            },\n        }, {\n            eventType: \"matchSetup\",\n            characterSourceId: this._character.uniqueId,\n            callback: () => {\n                const targetList = this._character.teammates.filter((ally) => ally.statusEffect.hasStatusEffect(\"Guard\"));\n                targetList.forEach((target) => {\n                    target.events.push({\n                        eventType: \"receiveDamage\",\n                        characterSourceId: this._character.uniqueId,\n                        callback: ({ attackSource }) => {\n                            if (attackSource) {\n                                const furiousBowcasterAbility = this._character.activeAbilities.find((ability) => ability.id === \"specialskill_CHEWBACCALEGENDARY02\");\n                                if (furiousBowcasterAbility) {\n                                    furiousBowcasterAbility.changeCooldown(-1, this);\n                                }\n                            }\n                        },\n                    });\n                });\n            },\n        }, {\n            eventType: \"endOfTurn\",\n            characterSourceId: this._character.uniqueId,\n            callback: () => {\n                triggers = [];\n            },\n        });\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_CHEWBACCALEGENDARY\", basicskill_CHEWBACCALEGENDARY],\n]);\nconst specialAbilities = new Map([\n    [\"specialskill_CHEWBACCALEGENDARY01\", specialskill_CHEWBACCALEGENDARY01],\n    [\"specialskill_CHEWBACCALEGENDARY02\", specialskill_CHEWBACCALEGENDARY02],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueskill_CHEWBACCALEGENDARY01\", uniqueskill_CHEWBACCALEGENDARY01],\n    [\"uniqueskill_CHEWBACCALEGENDARY02\", uniqueskill_CHEWBACCALEGENDARY02],\n]);\nconst leaderAbility = new Map([]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/CHEWBACCALEGENDARY.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/COMMANDERLUKESKYWALKER.ts":
/*!*************************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/COMMANDERLUKESKYWALKER.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n\n\nclass basicskill_COMMANDERLUKESKYWALKER extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_COMMANDERLUKESKYWALKER\", \"Destined Strike\", `Deal Physical damage to target enemy and inflict Speed Down and Defense Down for 2 turns. If the target already had Speed Down, remove 30% Turn Meter. If the target already had Defense Down, inflict Stun for 1 turn.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                if (!this.checkEvade(\"physical\", primaryTarget)) {\n                    this.dealDamage(\"physical\", primaryTarget, 1.781, 5, stats, canBeCountered);\n                    if (primaryTarget.checkCondition(() => {\n                        return primaryTarget.statusEffect.hasDebuff(\"Speed Down\");\n                    })) {\n                        primaryTarget.changeTurnMeter(-30, this);\n                    }\n                    if (primaryTarget.checkCondition(() => {\n                        return primaryTarget.statusEffect.hasDebuff(\"Defense Down\");\n                    })) {\n                        this._character?.statusEffect.inflictDebuff([{ name: \"Stun\", duration: 1, id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), sourceAbility: this }], primaryTarget, 1, this);\n                    }\n                    this._character?.statusEffect.inflictDebuff([\n                        {\n                            name: \"Speed Down\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                        {\n                            name: \"Defense Down\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                    ], primaryTarget, 1, this);\n                }\n            }\n        });\n    }\n}\nclass specialskill_COMMANDERLUKESKYWALKER02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_COMMANDERLUKESKYWALKER02\", \"Call to Action\", `Dispel all debuffs on Luke. Luke gains 100% Turn Meter and recovers 40% Health and Protection. If Luke doesn't have Call to Action, he gains it until the next time this ability is used, which can't be copied, dispelled, or prevented. If Luke already had Call to Action, he removes it.\\n\\nCall to Action: This character ignores Taunt during their turn and has +50% Accuracy, Critical Chance, and Critical Damage`, character);\n        this.cooldown = 4;\n    }\n    execute() {\n        const primaryTarget = this.findRandomEnemy();\n        super.execute(primaryTarget, [], false, () => {\n            this._character?.statusEffect.removeDebuff(\"all\", this._character);\n            this._character?.changeTurnMeter(100, this);\n            this._character?.heal({\n                healthType: \"protection\",\n                amountType: \"multiplicative\",\n                amount: 0.4,\n            }, this);\n            this._character?.heal({\n                healthType: \"health\",\n                amountType: \"multiplicative\",\n                amount: 0.4,\n            }, this);\n            if (this._character?.checkCondition(() => {\n                return this._character.statusEffect.hasBuff(\"Call to Action\");\n            })) {\n                this._character?.statusEffect.removeBuff(\"Call to Action\", this._character);\n            }\n            else {\n                this._character?.statusEffect.addBuff([\n                    {\n                        name: \"Call to Action\",\n                        duration: Infinity,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        cantDispel: true,\n                        cantResist: true,\n                        unique: true,\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n            }\n        });\n    }\n}\nclass specialskill_COMMANDERLUKESKYWALKER01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_COMMANDERLUKESKYWALKER01\", \"Use the Force\", `Deal Physical damage to target enemy, Dispel all buffs on them, remove 100% Turn Meter, and inflict Buff Immunity and Tenacity Down for 2 turns. Reduce the cooldown of this ability by 1 if the target didn't have full Health.`, character);\n        this.cooldown = 4;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                if (primaryTarget.stats.health < primaryTarget.stats.maxHealth) {\n                    this.changeCooldown(-1, this);\n                }\n                primaryTarget.statusEffect.removeBuff(\"all\");\n                this._character?.statusEffect.inflictDebuff([\n                    {\n                        name: \"Buff Immunity\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        sourceAbility: this,\n                    },\n                ], primaryTarget, 1, this);\n                this.dealDamage(\"physical\", primaryTarget, 2.978);\n                primaryTarget.changeTurnMeter(-100, this);\n                this._character?.statusEffect.inflictDebuff([\n                    {\n                        name: \"Tenacity Down\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        cantResist: true,\n                        sourceAbility: this,\n                    },\n                ], primaryTarget, 1, this);\n            }\n        });\n    }\n}\nclass uniqueskill_COMMANDERLUKESKYWALKER02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_COMMANDERLUKESKYWALKER02\", \"It Binds All Things\", `Luke has +40% Potency. Whenever Luke Resists a detrimental effect he recovers 5% Health and 5% Protection. Whenever Luke inflicts a debuff he gains 10% Turn Meter and other allies gain half that amount.`, character);\n    }\n    activate() {\n        this._character?.stats.addTempStats([\n            {\n                statToModify: \"potency\",\n                amount: 0.4,\n                modifiedType: \"additive\",\n            },\n        ], this);\n        this._character?.events.push({\n            characterSourceId: this._character.uniqueId,\n            eventType: \"resisted\",\n            callback: () => {\n                this._character?.heal({\n                    amount: 0.05,\n                    healthType: \"protection\",\n                    amountType: \"multiplicative\",\n                }, this);\n                this._character?.heal({\n                    amount: 0.05,\n                    healthType: \"health\",\n                    amountType: \"multiplicative\",\n                }, this);\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"inflicted\",\n            callback: () => {\n                this._character?.changeTurnMeter(10, this);\n                this._character?.teammates.forEach((target) => {\n                    if (!target.isSelf(this._character)) {\n                        target.changeTurnMeter(5, this);\n                    }\n                });\n            },\n        });\n    }\n}\nclass uniqueskill_COMMANDERLUKESKYWALKER01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_COMMANDERLUKESKYWALKER01\", \"Learn Control\", `While Luke doesn't have Call to Action, he has +50% Counter Chance, +50% Critical Avoidance, +50% Defense, +100% Tenacity, and gains 10% Turn Meter whenever another Rebel ally takes damage.`, character);\n    }\n    activate() {\n        this._character?.stats.addTempStats([\n            {\n                statToModify: \"counterChance\",\n                amount: 0.5,\n                modifiedType: \"additive\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"physicalCritAvoid\",\n                amount: 0.5,\n                modifiedType: \"additive\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"specialCritAvoid\",\n                amount: 0.5,\n                modifiedType: \"additive\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"physicalArmor\",\n                amount: 0.5,\n                modifiedType: \"multiplicative\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"specialArmor\",\n                amount: 0.5,\n                modifiedType: \"multiplicative\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"tenacity\",\n                amount: 1,\n                modifiedType: \"additive\",\n                condition: () => {\n                    return !this._character.statusEffect.hasBuff(\"Call to Action\");\n                },\n                characterSourceId: this._character.uniqueId,\n            },\n        ], this);\n        const targetList = this._character.teammates.filter((ally) => {\n            return ally.hasTags(\"Rebel & !Self\", this._character.id);\n        });\n        targetList.forEach((target) => {\n            target.events.push({\n                characterSourceId: this._character?.uniqueId,\n                eventType: \"receiveDamage\",\n                callback: () => {\n                    this._character?.changeTurnMeter(10, this);\n                },\n            });\n        });\n    }\n}\nclass leaderskill_COMMANDERLUKESKYWALKER extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"leaderskill_COMMANDERLUKESKYWALKER\", \"Rebel Maneuvers\", `Rebel allies have +50% Counter Chance, +50% Defense, and +15% Offense. Whenever an enemy Resists a detrimental effect, Rebel allies gain 5% Turn Meter.`, character);\n    }\n    activate() {\n        const targetList = this._character.teammates.filter((ally) => {\n            return ally.hasTags(\"Rebel\", this._character.id);\n        });\n        targetList.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    statToModify: \"counterChance\",\n                    amount: 0.5,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"physicalArmor\",\n                    amount: 0.5,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"specialArmor\",\n                    amount: 0.5,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"physicalOffense\",\n                    amount: 0.15,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"specialOffense\",\n                    amount: 0.15,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n            ], this);\n            target.events.push({\n                characterSourceId: this._character?.uniqueId ?? \"\",\n                eventType: \"resisted\",\n                callback: () => {\n                    target.changeTurnMeter(5, this);\n                },\n            });\n        });\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_COMMANDERLUKESKYWALKER\", basicskill_COMMANDERLUKESKYWALKER],\n]);\nconst specialAbilities = new Map([\n    [\n        \"specialskill_COMMANDERLUKESKYWALKER02\",\n        specialskill_COMMANDERLUKESKYWALKER02,\n    ],\n    [\n        \"specialskill_COMMANDERLUKESKYWALKER01\",\n        specialskill_COMMANDERLUKESKYWALKER01,\n    ],\n]);\nconst uniqueAbilities = new Map([\n    [\n        \"uniqueskill_COMMANDERLUKESKYWALKER01\",\n        uniqueskill_COMMANDERLUKESKYWALKER01,\n    ],\n    [\n        \"uniqueskill_COMMANDERLUKESKYWALKER02\",\n        uniqueskill_COMMANDERLUKESKYWALKER02,\n    ],\n]);\nconst leaderAbility = new Map([\n    [\"leaderskill_COMMANDERLUKESKYWALKER\", leaderskill_COMMANDERLUKESKYWALKER],\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/COMMANDERLUKESKYWALKER.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/GENERALSKYWALKER/abilities.ts":
/*!*****************************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/GENERALSKYWALKER/abilities.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n\n\nclass basicskill_GENERALSKYWALKER extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_GENERALSKYWALKER\", \"Furious Slash\", `Deal Physical damage to target enemy. This attack can't be evaded and has +65% Defense Penetration, tripled if all allies are 501st.\n\n      If this is the first ability General Skywalker uses during his turn, he immediately uses the Special ability Telekinesis, if able.\n      \n      Telekinesis: Deal Physical damage to target enemy. If possible, this attack will critically hit enemies with Armor Shred. If the target enemy is Dazed, reduce General Skywalker's ability cooldowns by 1.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            const allAllies501st = this._character.teammates.every((ally) => ally.hasTags(\"501st\", this._character.id));\n            const newStats = [\n                ...(stats ?? []),\n                {\n                    statToModify: \"specialArmorPen\",\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character.uniqueId,\n                    amount: allAllies501st ? 0.65 * 3 : 0.65,\n                },\n                {\n                    statToModify: \"physicalArmorPen\",\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character.uniqueId,\n                    amount: allAllies501st ? 0.65 * 3 : 0.65,\n                },\n            ];\n            if (primaryTarget) {\n                this.dealDamage(\"physical\", primaryTarget, 2.2, 5, newStats, canBeCountered);\n            }\n        });\n    }\n}\nclass grantedability_GENERALSKYWALKER extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"grantedability_GENERALSKYWALKER\", \"Telekinesis\", `Deal Physical damage to target enemy. If possible, this attack will critically hit enemies with Armor Shred. If the target enemy is Dazed, reduce General Skywalker's ability cooldowns by 1.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                const hasArmorShred = primaryTarget?.statusEffect.hasStatusEffect(\"Armor Shred\");\n                const newStats = [\n                    ...(stats ?? []),\n                    {\n                        statToModify: \"physicalCritChance\",\n                        modifiedType: \"additive\",\n                        characterSourceId: this._character.uniqueId,\n                        amount: hasArmorShred ? Infinity : 0,\n                    },\n                    {\n                        statToModify: \"specialCritChance\",\n                        modifiedType: \"multiplicative\",\n                        characterSourceId: this._character.uniqueId,\n                        amount: hasArmorShred ? Infinity : 0,\n                    },\n                ];\n                this.dealDamage(\"physical\", primaryTarget, 2.8, 5, newStats, canBeCountered);\n                if (primaryTarget?.statusEffect.hasDebuff(\"Daze\")) {\n                    this._character.specialAbilities.forEach((ability) => {\n                        ability.changeCooldown(-1, this, this._character);\n                    });\n                }\n            }\n        });\n    }\n}\nclass specialskill_GENERALSKYWALKER01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_GENERALSKYWALKER01\", \"Sundering Strike\", `Deal Physical damage to target enemy and inflict Armor Shred. If they are Dazed, this attack deals double damage.\n\n      If this is the first ability General Skywalker uses during his turn, reset Force Grip's cooldown and use it if possible.`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                if (!this.checkEvade(\"physical\", primaryTarget)) {\n                    this.dealDamage(\"physical\", primaryTarget, primaryTarget.statusEffect.hasDebuff(\"Daze\") ? 7 : 3.5, 5, stats, canBeCountered);\n                    primaryTarget.statusEffect.addStatusEffect({\n                        name: \"Armor Shred\",\n                        duration: Infinity,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        sourceAbility: this,\n                        cantResist: true,\n                        isStackable: true,\n                    }, this);\n                }\n            }\n        });\n    }\n}\nclass specialskill_GENERALSKYWALKER02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_GENERALSKYWALKER02\", \"Force Grip\", `Deal Physical damage to all enemies and Daze them for 2 turns. If possible, this attack will critically hit enemies with Armor Shred.\n\n      If this is the first ability General Skywalker uses during his turn, reset Sundering Strike's cooldown and use it if possible.`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            this._character.opponents.forEach((target) => {\n                if (!this.checkEvade(\"physical\", target)) {\n                    this._character.statusEffect.inflictDebuff([{ name: \"Daze\", duration: 2, id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), sourceAbility: this }], target, 1, this);\n                    const hasArmorShred = target.statusEffect.hasStatusEffect(\"Armor Shred\");\n                    const newStats = [\n                        ...(stats ?? []),\n                        {\n                            statToModify: \"physicalCritChance\",\n                            modifiedType: \"additive\",\n                            characterSourceId: this._character.uniqueId,\n                            amount: hasArmorShred ? Infinity : 0,\n                        },\n                        {\n                            statToModify: \"specialCritChance\",\n                            modifiedType: \"additive\",\n                            characterSourceId: this._character.uniqueId,\n                            amount: hasArmorShred ? Infinity : 0,\n                        },\n                    ];\n                    this.dealDamage(\"physical\", target, 3, 5, stats, canBeCountered);\n                    target.statusEffect.addStatusEffect({\n                        name: \"Armor Shred\",\n                        duration: Infinity,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        sourceAbility: this,\n                        cantResist: true,\n                        isStackable: true,\n                    }, this);\n                }\n            });\n        });\n    }\n}\nclass uniqueskill_GENERALSKYWALKER01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_GENERALSKYWALKER01\", \"The Chosen One\", `General Skywalker uses an additional ability during his turn.\n\n    Whenever General Skywalker critically hits an enemy during his turn, increase their cooldowns by 1 (excluding raid bosses and Galactic Legends), which can't be resisted.\n    \n    If he is critically hit, General Skywalker dispels all debuffs on himself. Enemies attacking out of turn can't critically hit.\n    \n    If the target enemy has no Protection when General Skywalker uses an ability, reduce their current Max Health by 20% for rest of the battle (stacking, excluding raid bosses and Galactic Legends), which can't be resisted.`, character);\n    }\n    activate() {\n        this._character?.events.push({\n            characterSourceId: this._character.uniqueId,\n            eventType: \"receiveDamage\",\n            callback: ({ isCrit }) => {\n                if (isCrit) {\n                    this._character.statusEffect.removeDebuff(\"all\", undefined, this);\n                }\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"dealDamage\",\n            callback: ({ isCrit, target, }) => {\n                if (isCrit &&\n                    this._character.gameEngine.currentCharactersTurn?.isSelf(this._character) &&\n                    !target.hasTags(\"Galactic Legend\", \"\")) {\n                    target.specialAbilities.forEach((ability) => {\n                        ability.changeCooldown(1, this, this._character, true);\n                    });\n                }\n            },\n        }, {\n            eventType: \"beforeUseAbility\",\n            characterSourceId: this._character.uniqueId,\n            callback: ({ target }) => {\n                if (!target.hasTags(\"Galactic Legend\", \"\")) {\n                    target.stats.addTempStats([\n                        {\n                            statToModify: \"maxHealth\",\n                            amount: -0.2,\n                            modifiedType: \"multiplicative\",\n                            characterSourceId: this._character.uniqueId,\n                        },\n                    ], this);\n                }\n            },\n        });\n        this._character.opponents.forEach((opponent) => {\n            opponent.statusEffect.addImmune(\"cant_crit_out_of_turn\", \"Crit\", () => {\n                return !this._character.gameEngine.currentCharactersTurn?.isSelf(opponent);\n            });\n        });\n    }\n}\nclass uniqueskill_GENERALSKYWALKER02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueskill_GENERALSKYWALKER02\", \"Hero with no Fear\", `At the start of battle, General Skywalker gains 25% Defense, 15% Max Protection, and 25% Tenacity for each other 501st ally until all other 501st allies are defeated.\n\n    If all allies are 501st at the start of battle, General Skywalker gains the following:\n    \n    - 100% counter chance and 50% Critical Chance\n    \n    - When all other allies are defeated, General Skywalker can't be critically hit and gains 35% Turn Meter after every enemy turn`, character);\n    }\n    activate() {\n        const allies501st = this._character.teammates.filter((ally) => ally.hasTags(\"501st\", \"\") && !ally.isSelf(this._character));\n        if (allies501st.length > 0) {\n            this._character?.stats.addTempStats([\n                {\n                    statToModify: \"physicalArmor\",\n                    amount: 0.25 * allies501st.length * this._character.stats.physical.armor,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                    id: \"uniqueskill_GENERALSKYWALKER02\",\n                },\n                {\n                    statToModify: \"specialArmor\",\n                    amount: 0.25 * allies501st.length * this._character.stats.special.armor,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                    id: \"uniqueskill_GENERALSKYWALKER02\",\n                },\n                {\n                    statToModify: \"maxProtection\",\n                    amount: 0.15 * allies501st.length,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character.uniqueId,\n                    id: \"uniqueskill_GENERALSKYWALKER02\",\n                },\n                {\n                    statToModify: \"tenacity\",\n                    amount: 0.25 * allies501st.length,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character.uniqueId,\n                    id: \"uniqueskill_GENERALSKYWALKER02\",\n                },\n            ], this);\n            allies501st.forEach((ally) => {\n                ally.events.push({\n                    eventType: \"death\",\n                    characterSourceId: this._character.uniqueId,\n                    callback: () => {\n                        const all501stAreDead = this._character.teammates.every((ally) => {\n                            if (!ally.isSelf(this._character) && ally.hasTags(\"501st\", \"\")) {\n                                return ally.isDead;\n                            }\n                            return true;\n                        });\n                        if (all501stAreDead) {\n                            this._character.stats.removeTempStats(\"\", \"uniqueskill_GENERALSKYWALKER02\");\n                        }\n                    },\n                });\n            });\n        }\n        if (this._character.teammates.every((ally) => ally.hasTags(\"501st\", \"\"))) {\n            this._character.stats.addTempStats([\n                {\n                    statToModify: \"counterChance\",\n                    amount: 1,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"physicalCritChance\",\n                    amount: 0.5,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"specialCritChance\",\n                    amount: 0.5,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                },\n                {\n                    statToModify: \"specialCritAvoid\",\n                    amount: Infinity,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                    condition: () => {\n                        return this._character.teammates.every((ally) => {\n                            if (!ally.isSelf(this._character)) {\n                                return ally.isDead;\n                            }\n                            return true;\n                        });\n                    },\n                },\n                {\n                    statToModify: \"physicalCritAvoid\",\n                    amount: Infinity,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character.uniqueId,\n                    condition: () => {\n                        return this._character.teammates.every((ally) => {\n                            if (!ally.isSelf(this._character)) {\n                                return ally.isDead;\n                            }\n                            return true;\n                        });\n                    },\n                },\n            ], this);\n            this._character.teammates.forEach((ally) => {\n                ally.events.push({\n                    eventType: \"death\",\n                    characterSourceId: this._character.uniqueId,\n                    callback: () => {\n                        const allOtherAlliesAreDead = this._character.teammates.every((ally) => {\n                            if (!ally.isSelf(this._character)) {\n                                return ally.isDead;\n                            }\n                            return true;\n                        });\n                        if (allOtherAlliesAreDead) {\n                            this._character.events.push({\n                                eventType: \"endOfTurn\",\n                                characterSourceId: this._character.uniqueId,\n                                id: \"gain_tm_with_no_allies\",\n                                callback: ({ target }) => {\n                                    if (target.owner !== this._character.owner) {\n                                        this._character.changeTurnMeter(35, this);\n                                    }\n                                },\n                            });\n                        }\n                    },\n                }, {\n                    eventType: \"revive\",\n                    characterSourceId: this._character.uniqueId,\n                    callback: () => {\n                        this._character.events = this._character.events.filter((event) => {\n                            return event.id !== \"gain_tm_with_no_allies\";\n                        });\n                    },\n                });\n            });\n        }\n    }\n}\nclass leaderskill_GENERALSKYWALKER extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"leaderskill_GENERALSKYWALKER\", \"General of the 501st\", `All units can't be revived.\n      All 501st allies have +50% Critical Damage.\n      When an enemy gains a buff, all 501st allies gain 2% Offense (stacking) until the end of the encounter.\n      \n      While there are other active 501st allies, General Skywalker:\n      - Can't drop below 100% Health\n      - Advances if he has 100% Protection and takes Cover if he has 0% Protection at the end of every turn\n      - Removes all other status effects when he takes Cover\n      - Leaves Cover, recovers 100% Protection, and takes a bonus turn when all other 501st allies are defeated\n      \n      Advance:\n      - Taunt, which can't be dispelled or prevented\n      - Other 501st allies can't lose Health\n      Cover:\n      - Can't be targeted\n      - Immune to damage and status effects\n      - Speed set to 0\n      - Recover 10% Protection and Turn Meter at the end of every turn, doubled for allied 501st turns, which can't be prevented`, character);\n    }\n    activate() {\n        [...this._character.teammates, ...this._character.opponents].forEach((character) => {\n            character.statusEffect.addImmune(\"GENERALSKYWALKER_leadership_no_revive\", \"Revive\", undefined, this);\n        });\n        this._character.events.push({\n            eventType: \"gainStatusEffect\",\n            characterSourceId: this._character.uniqueId,\n            callback: ({ statusEffect }) => {\n                if (statusEffect.name === \"Cover\") {\n                    this._character.statusEffect.removeBuff(\"all\");\n                    this._character.statusEffect.removeDebuff(\"all\");\n                }\n                else if (statusEffect.name === \"Advance\") {\n                    this._character.heal({\n                        healthType: \"protection\",\n                        amountType: \"multiplicative\",\n                        amount: 1,\n                    }, this);\n                    this._character.statusEffect.addBuff([\n                        {\n                            name: \"Taunt\",\n                            id: \"advance_taunt\",\n                            duration: Infinity,\n                            cantDispel: true,\n                            cantPrevent: true,\n                            sourceAbility: this,\n                        },\n                    ], 1, this);\n                }\n            },\n        }, {\n            eventType: \"endOfTurn\",\n            characterSourceId: this._character.uniqueId,\n            callback: ({ character }) => {\n                if (this._character.stats.protection >=\n                    this._character.stats.maxProtection) {\n                    if (!this._character.statusEffect.hasStatusEffect(\"Advance\")) {\n                        this._character.statusEffect.addStatusEffect([\n                            {\n                                name: \"Advance\",\n                                duration: Infinity,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                                sourceAbility: this,\n                            },\n                        ], this);\n                        this._character.statusEffect.removeStatusEffect(\"Cover\", this);\n                        const all501stAreDead = this._character.teammates.every((ally) => {\n                            return !ally.isSelf(this._character) && ally.isDead;\n                        });\n                        if (all501stAreDead) {\n                            this._character.hasBonusTurn = true;\n                        }\n                    }\n                }\n                else if (this._character.stats.protection <= 0) {\n                    if (!this._character.statusEffect.hasStatusEffect(\"Cover\")) {\n                        this._character.statusEffect.addStatusEffect([\n                            {\n                                name: \"Cover\",\n                                duration: Infinity,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                                sourceAbility: this,\n                            },\n                        ], this);\n                        this._character.statusEffect.removeStatusEffect(\"Advance\", this);\n                    }\n                }\n                if (this._character.statusEffect.hasStatusEffect(\"Cover\")) {\n                    const on501stTurn = character.hasTags(\"501st\", \"\") &&\n                        character.owner === this._character.owner;\n                    this._character.heal({\n                        healthType: \"protection\",\n                        amountType: \"multiplicative\",\n                        amount: on501stTurn ? 0.2 : 0.1,\n                    }, this);\n                    this._character.changeTurnMeter(on501stTurn ? 20 : 10, this, this._character);\n                }\n            },\n        });\n        this._character.statusEffect.addImmune(\"501st_cant_lose_health\", \"loseHealth\", () => {\n            return this._character.statusEffect.hasStatusEffect(\"Cover\");\n        });\n        const allies501st = this._character.teammates.filter((ally) => {\n            return ally.hasTags(\"501st\", this._character.id);\n        });\n        allies501st.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    statToModify: \"critDamage\",\n                    amount: 0.5,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n            ], this);\n            target.statusEffect.addImmune(\"501st_cant_lose_health\", \"loseHealth\", () => {\n                return this._character.statusEffect.hasStatusEffect(\"Advance\");\n            });\n        });\n        this._character.opponents.forEach((enemy) => {\n            enemy.events.push({\n                eventType: \"buffed\",\n                characterSourceId: this._character.uniqueId,\n                callback: () => {\n                    allies501st.forEach((ally) => {\n                        ally.stats.addTempStats([\n                            {\n                                statToModify: \"physicalOffense\",\n                                amount: 0.02,\n                                modifiedType: \"multiplicative\",\n                            },\n                            {\n                                statToModify: \"specialOffense\",\n                                amount: 0.02,\n                                modifiedType: \"multiplicative\",\n                            },\n                        ], this);\n                    });\n                },\n            });\n        });\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_GENERALSKYWALKER\", basicskill_GENERALSKYWALKER],\n]);\nconst specialAbilities = new Map([\n    [\"specialskill_GENERALSKYWALKER01\", specialskill_GENERALSKYWALKER01],\n    [\"specialskill_GENERALSKYWALKER02\", specialskill_GENERALSKYWALKER02],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueskill_GENERALSKYWALKER01\", uniqueskill_GENERALSKYWALKER01],\n    [\"uniqueskill_GENERALSKYWALKER02\", uniqueskill_GENERALSKYWALKER02],\n]);\nconst leaderAbility = new Map([\n    [\"leaderskill_GENERALSKYWALKER\", leaderskill_GENERALSKYWALKER],\n]);\nconst hiddenAbilities = new Map([\n    [\"grantedability_GENERALSKYWALKER\", grantedability_GENERALSKYWALKER],\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n    hiddenAbilities,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/GENERALSKYWALKER/abilities.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/abilities.ts":
/*!****************************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/abilities.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n/* harmony import */ var _characters_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../characters/index */ \"./src/types/gameEngine/characters/index.ts\");\n\n\n\nclass basicskill_GRANDMASTERLUKE extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_GRANDMASTERLUKE\", \"Indomitable Blast\", `Inflict Buff Immunity on target enemy for 2 turns and deal Special damage to them. Luke gains 2% Max Health (stacking, max 20%) until the end of encounter. This attack will critically hit if able and can't be countered.`, character);\n    }\n    execute(targetCharacter, stats) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        let stackCounter = 0;\n        super.execute(primaryTarget, stats, false, () => {\n            if (primaryTarget) {\n                if (!this.checkEvade(\"special\", primaryTarget)) {\n                    this._character.statusEffect.inflictDebuff([\n                        {\n                            name: \"Buff Immunity\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                    ], primaryTarget, 1, this);\n                    this.dealDamage(\"special\", primaryTarget, 2, 5, [\n                        ...(stats ?? []),\n                        {\n                            statToModify: \"specialCritChance\",\n                            amount: 200,\n                            modifiedType: \"additive\",\n                            characterSourceId: this._character.uniqueId,\n                        },\n                    ], false);\n                }\n            }\n            if (stackCounter < 20) {\n                this._character.stats.addTempStats([\n                    {\n                        characterSourceId: this._character.uniqueId,\n                        statToModify: \"maxHealth\",\n                        amount: 0.02 * this._character.stats.maxHealth,\n                        modifiedType: \"additive\",\n                    },\n                ], this);\n                stackCounter++;\n            }\n        });\n    }\n}\nclass specialskill_GRANDMASTERLUKE01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_GRANDMASTERLUKE01\", \"They Grow Beyond\", `Inflict Tenacity Down on target enemy for 2 turns, then Daze them for 2 turns. Increase their cooldowns by 1.\\n\\nRaid Bosses: Inflict Tenacity Down on target enemy for 2 turns, then inflict 3 Expose for 2 turns on them.\\n\\nCall target other Light Side ally to assist, then grant them and Jedi Master Luke Skywalker Advantage and Critical Damage Up for 2 turns.\\n\\nIf target other ally is a Jedi, that ally gains Jedi Lessons for 3 turns, which can't be copied. If they already have Jedi Lessons, the duration for all current stacks on them resets to 3 turns (max 3 stacks).\\n\\nThis ability can't be resisted or evaded.\\n\\nJedi Lessons: +20% Mastery per stack`, character);\n        this.cooldown = 4;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            if (primaryTarget) {\n                this._character.statusEffect.inflictDebuff([\n                    {\n                        name: \"Tenacity Down\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        sourceAbility: this,\n                        cantResist: true,\n                    },\n                ], primaryTarget, 1, this);\n                this._character.statusEffect.inflictDebuff([\n                    {\n                        name: \"Daze\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        sourceAbility: this,\n                        cantResist: true,\n                    },\n                ], primaryTarget, 1, this);\n                primaryTarget.specialAbilities.forEach((ability) => {\n                    ability.changeCooldown(1, this, this._character, true);\n                });\n                const ally = this.findRandomAlly();\n                if (ally) {\n                    ally.assist([], primaryTarget, this);\n                    ally.statusEffect.addBuff([\n                        {\n                            name: \"Advantage\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                        {\n                            name: \"Critical Damage Up\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                    ], 1, this);\n                    if (ally.hasTags(\"Jedi\", this._character.id)) {\n                        ally.statusEffect.resetDuration(\"Jedi Lessons\", 3, \"buff\", this);\n                        ally.statusEffect.addBuff([\n                            {\n                                name: \"Jedi Lessons\",\n                                duration: 3,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                sourceAbility: this,\n                                isStackable: true,\n                                unique: true,\n                            },\n                        ], 1, this, 3);\n                    }\n                }\n                this._character.statusEffect.addBuff([\n                    {\n                        name: \"Advantage\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        sourceAbility: this,\n                    },\n                    {\n                        name: \"Critical Damage Up\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n            }\n        });\n    }\n}\nclass specialskill_GRANDMASTERLUKE02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_GRANDMASTERLUKE02\", \"They Grow Beyond\", `Deal Special damage to all enemies. Then, remove 20% Turn Meter from them and inflict Ability Block and Breach for 2 turns. Deal 10% more damage and remove an additional 5% Turn Meter for each ally with Jedi Lessons or Jedi Legacy.\\n\\nAll Jedi allies gain 15% Turn Meter and Critical Hit Immunity for 1 turn.`, character);\n        this.cooldown = 4;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            const jediWithLessonsOrLegacy = this._character.teammates.filter((ally) => {\n                return (ally.statusEffect.hasBuff(\"Jedi Lessons\") ||\n                    ally.statusEffect.hasBuff(\"Jedi Legacy\"));\n            });\n            this._character.opponents.forEach((target) => {\n                if (!this.checkEvade(\"special\", target)) {\n                    this.dealDamage(\"special\", target, 3, 5, [\n                        ...(stats ?? []),\n                        {\n                            statToModify: \"specialOffense\",\n                            amount: jediWithLessonsOrLegacy.length *\n                                0.1 *\n                                this._character.stats.special.offense,\n                            modifiedType: \"additive\",\n                            characterSourceId: this._character.uniqueId,\n                        },\n                    ], false);\n                    this._character.statusEffect.inflictDebuff([\n                        {\n                            name: \"Ability Block\",\n                            duration: 2,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                        { name: \"Breach\", duration: 2, id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), sourceAbility: this },\n                    ], target, 1, this);\n                    target.changeTurnMeter(-10 + jediWithLessonsOrLegacy.length * -5, this, this._character);\n                }\n            });\n            this._character.teammates.forEach((ally) => {\n                if ((0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Jedi\"], this._character.id)) {\n                    ally.changeTurnMeter(15, this, this._character);\n                    ally.statusEffect.addBuff([\n                        {\n                            name: \"Critical Hit Immunity\",\n                            duration: 1,\n                            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                            sourceAbility: this,\n                        },\n                    ], 1, this);\n                }\n            });\n        });\n    }\n}\nclass leaderskill_GRANDMASTERLUKE extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"leaderskill_GRANDMASTERLUKE\", \"Legend of the Jedi\", `All Light Side allies have +10% Max Health and Max Protection, doubled for Jedi allies. All Jedi allies have +30% Offense and +40 Speed.\n\n      If all allies are Jedi at the start of battle (excluding summoned allies), Jedi Master Luke Skywalker Taunts while he has Protection.\n      \n      The first time each other Jedi ally falls below 100% Health, they dispel all debuffs on themselves and gain Critical Hit Immunity, Defense Up, and Tenacity Up for 2 turns. Then, Luke Taunts for 2 turns, which can't be copied, dispelled, or prevented.\n      \n      At the start of battle, Jedi allies gain the granted ability Inherited Teachings.\n      \n      Inherited Teachings: Gain Jedi Lessons for 3 turns and call target other Light Side ally to assist, dealing 90% less damage. Then, they deal true damage to the target enemy based on 60% of Jedi Master Luke Skywalker's base Max Protection, which can't be evaded.\n      \n      If that ally is a Jedi, they gain Jedi Lessons for 3 turns and 15% Turn Meter, recover Protection equal to 5% of Luke's base Max Protection, and reduce the cooldown of their Inherited Teachings ability by 1.\n      \n      This ability can't be used if there are no other Jedi allies. (Cooldown: 2)`, character);\n    }\n    activate() {\n        const lightSideNonJediAllies = this._character.teammates.filter((ally) => {\n            return (0,_characters_index__WEBPACK_IMPORTED_MODULE_1__.anyTagsMatch)(ally, [\"Light Side & !Jedi\"], this._character.id);\n        });\n        const jediAllies = this._character.teammates.filter((ally) => {\n            return ally.hasTags(\"Jedi\", this._character.id);\n        });\n        const triggeredList = [];\n        lightSideNonJediAllies.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    statToModify: \"maxHealth\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"maxProtection\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n            ], this);\n        });\n        jediAllies.forEach((target) => {\n            target.stats.addTempStats([\n                {\n                    statToModify: \"maxHealth\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"maxProtection\",\n                    amount: 0.2,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"physicalOffense\",\n                    amount: 0.3,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"specialOffense\",\n                    amount: 0.3,\n                    modifiedType: \"multiplicative\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n                {\n                    statToModify: \"speed\",\n                    amount: 40,\n                    modifiedType: \"additive\",\n                    characterSourceId: this._character?.uniqueId,\n                },\n            ], this);\n            target.events.push({\n                eventType: \"loseHealth\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ previousHealth }) => {\n                    if (target.stats.health < target.stats.maxHealth &&\n                        previousHealth >= target.stats.maxHealth) {\n                        const alreadyTriggered = triggeredList.some((x) => x === target.uniqueId);\n                        if (!alreadyTriggered) {\n                            triggeredList.push(target.uniqueId);\n                            target.statusEffect.removeDebuff(\"all\");\n                            target.statusEffect.addBuff([\n                                {\n                                    name: \"Critical Hit Immunity\",\n                                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                    duration: 2,\n                                    sourceAbility: this,\n                                },\n                                {\n                                    name: \"Defense Up\",\n                                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                    duration: 2,\n                                    sourceAbility: this,\n                                },\n                                {\n                                    name: \"Tenacity Up\",\n                                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                    duration: 2,\n                                    sourceAbility: this,\n                                },\n                            ], 1, this);\n                            this._character.statusEffect.addBuff([\n                                {\n                                    name: \"Taunt\",\n                                    duration: 2,\n                                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                                    sourceAbility: this,\n                                    unique: true,\n                                    cantDispel: true,\n                                    cantPrevent: true,\n                                },\n                            ], 1, this);\n                        }\n                    }\n                },\n            });\n            target.addGrantedAbility(new grantedability_grandmasterluke_inherited_teachings(target));\n        });\n        const allAreJediAllies = this._character.teammates.every((ally) => {\n            return ally.hasTags(\"Jedi\", this._character.id);\n        });\n        if (allAreJediAllies) {\n            const tauntId = \"GRANDMASTERLUKE_TauntWhileProtection\";\n            this._character.events.push({\n                eventType: \"matchSetup\",\n                characterSourceId: this._character.uniqueId,\n                callback: () => {\n                    this._character.statusEffect.addBuff([\n                        {\n                            name: \"Taunt\",\n                            duration: Infinity,\n                            sourceAbility: this,\n                            id: tauntId,\n                        },\n                    ], 1, this);\n                },\n            }, {\n                eventType: \"loseProtection\",\n                characterSourceId: this._character.uniqueId,\n                callback: () => {\n                    if (this._character.stats.protection <= 0) {\n                        this._character.statusEffect.removeBuff({\n                            name: null,\n                            duration: 0,\n                            sourceAbility: this,\n                            id: tauntId,\n                        });\n                    }\n                },\n            }, {\n                eventType: \"dispel\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ effects }) => {\n                    effects.forEach((effect) => {\n                        if (effect.id === tauntId) {\n                            this._character.statusEffect.addBuff([\n                                {\n                                    name: \"Taunt\",\n                                    duration: Infinity,\n                                    sourceAbility: this,\n                                    id: tauntId,\n                                },\n                            ], 1, this);\n                        }\n                    });\n                },\n            });\n        }\n    }\n}\nclass grantedability_grandmasterluke_inherited_teachings extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"grantedability_grandmasterluke_inherited_teachings\", \"Inherited Teachings\", `Gain Jedi Lessons for 3 turns and call target other Light Side ally to assist, dealing 90% less damage. Then, they deal true damage to the target enemy based on 60% of Jedi Master Luke Skywalker's base Max Protection, which can't be evaded.\n      \n      If that ally is a Jedi, they gain Jedi Lessons for 3 turns and 15% Turn Meter, recover Protection equal to 5% of Luke's base Max Protection, and reduce the cooldown of their Inherited Teachings ability by 1.\n      \n      This ability can't be used if there are no other Jedi allies. (Cooldown: 2)`, character);\n        this.cooldown = 2;\n    }\n    get canBeUsed() {\n        return (this._character.teammates.filter((ally) => ally.hasTags(\"Jedi\", this._character.id)).length > 0);\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        this._character.statusEffect.addBuff([{ name: \"Jedi Lessons\", id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), duration: 3, sourceAbility: this }], 1, this);\n        const lightSideAlly = this.findTargets(this._character.teammates.filter((ally) => ally.hasTags(\"Light Side\", this._character.id)));\n        if (lightSideAlly) {\n            lightSideAlly.assist([\n                {\n                    statToModify: \"specialOffense\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                },\n                {\n                    statToModify: \"physicalOffense\",\n                    amount: 0.1,\n                    modifiedType: \"multiplicative\",\n                },\n            ], targetCharacter, this);\n            const jml = this._character.teammates.find((ally) => ally.id === \"GRANDMASTERLUKE\");\n            if (jml) {\n                targetCharacter?.receiveDamage(\"true\", jml.stats.baseStats.maxProtection * 0.6, 0, 0, 0, []);\n            }\n            if (lightSideAlly.hasTags(\"Jedi\", this._character.id)) {\n                lightSideAlly.statusEffect.addBuff([\n                    {\n                        name: \"Jedi Lessons\",\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        duration: 3,\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n                lightSideAlly.changeTurnMeter(15, this, this._character);\n                if (jml) {\n                    lightSideAlly.heal({\n                        healthType: \"protection\",\n                        amount: 0.05 * jml?.stats.baseStats.maxProtection,\n                        amountType: \"additive\",\n                    }, this);\n                }\n                const ineritedTeaching = lightSideAlly.specialAbilities.find((ability) => ability.id === \"grantedability_grandmasterluke_inherited_teachings\");\n                if (ineritedTeaching) {\n                    ineritedTeaching.changeCooldown(-1, this, this._character);\n                }\n            }\n        }\n    }\n}\nclass uniqueability_grandmasterluke01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueability_grandmasterluke01\", \"Jedi Legacy\", `Jedi allies may gain Jedi Lessons.\n\n      The first time each other Light Side ally falls below 100% Health, they recover 25% Health and Protection, doubled for Jedi allies.\n      \n      At the start of battle, Jedi Master Luke Skywalker gains Jedi Legacy until the end of battle, which can't be copied, dispelled, or prevented.\n      \n      Jedi Legacy: +100% Mastery and ignores Taunt effects during their turn; can't gain Jedi Lessons`, character);\n    }\n    activate() {\n        const lightSideAllies = this._character.teammates.filter((ally) => {\n            return ally.hasTags(\"Light Side\", this._character.id);\n        });\n        const triggeredList = [];\n        lightSideAllies.forEach((target) => {\n            target.events.push({\n                eventType: \"loseHealth\",\n                characterSourceId: this._character.uniqueId,\n                callback: ({ previousHealth }) => {\n                    if (target.stats.health < target.stats.maxHealth &&\n                        previousHealth >= target.stats.maxHealth) {\n                        const alreadyTriggered = triggeredList.some((x) => x === target.uniqueId);\n                        if (!alreadyTriggered) {\n                            triggeredList.push(target.uniqueId);\n                            const isJedi = target.hasTags(\"Jedi\", this._character.id);\n                            target.heal({\n                                amount: isJedi ? 0.5 : 0.25,\n                                healthType: \"health\",\n                                amountType: \"multiplicative\",\n                            }, this);\n                            target.heal({\n                                amount: isJedi ? 0.5 : 0.25,\n                                healthType: \"protection\",\n                                amountType: \"multiplicative\",\n                            }, this);\n                        }\n                    }\n                },\n            });\n        });\n        this._character.events.push({\n            eventType: \"matchSetup\",\n            characterSourceId: this._character.uniqueId,\n            callback: () => {\n                this._character.statusEffect.addBuff([\n                    {\n                        name: \"Jedi Legacy\",\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n                        duration: Infinity,\n                        cantDispel: true,\n                        unique: true,\n                        cantPrevent: true,\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n            },\n        });\n    }\n}\nclass uniqueability_galacticlegend01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    constructor(character) {\n        super(\"uniqueability_galacticlegend01\", \"Galactic Legend\", `This unit takes reduced damage from percent Health damage effects and massive damage effects. They take massive damage from destroy effects (excludes raid bosses) and are immune to stun effects.\n\n      This unit has +10% Max Health and Max Protection per Relic Amplifier level, and damage they receive is decreased by 30%.`, character);\n    }\n    activate() {\n        this._character.stats.addTempStats([\n            {\n                statToModify: \"protection\",\n                amount: 0.1 *\n                    this._character.relicLevel *\n                    this._character.stats.maxProtection,\n                modifiedType: \"additive\",\n                characterSourceId: this._character.uniqueId,\n            },\n            {\n                statToModify: \"health\",\n                amount: 0.1 * this._character.relicLevel * this._character.stats.maxHealth,\n                modifiedType: \"additive\",\n                characterSourceId: this._character.uniqueId,\n            },\n        ], this);\n        //todo\n        // this._character.events.push({\n        //   eventType: \"destroy\",\n        //   characterSourceId: this._character.uniqueId,\n        //   callback: () => {\n        //   }\n        // })\n        this._character.statusEffect.addImmune(\"jml_galactic_legend\", \"Fear\", undefined, this);\n        this._character.statusEffect.addImmune(\"jml_galactic_legend\", \"Stun\", undefined, this);\n        // this._character.statusEffect.addImmune(\"jml_galactic_legend\", \"Destroy\", undefined, this)\n    }\n}\nconst basicAbility = new Map([\n    [\"basicskill_GRANDMASTERLUKE\", basicskill_GRANDMASTERLUKE],\n]);\nconst specialAbilities = new Map([\n    [\"specialskill_GRANDMASTERLUKE01\", specialskill_GRANDMASTERLUKE01],\n    [\"specialskill_GRANDMASTERLUKE02\", specialskill_GRANDMASTERLUKE02],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueability_grandmasterluke01\", uniqueability_grandmasterluke01],\n]);\nconst leaderAbility = new Map([\n    [\"leaderskill_GRANDMASTERLUKE\", leaderskill_GRANDMASTERLUKE],\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/abilities.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/character.ts":
/*!****************************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/character.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _characters_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../characters/index */ \"./src/types/gameEngine/characters/index.ts\");\n\nclass GRANDMASTERLUKE extends _characters_index__WEBPACK_IMPORTED_MODULE_0__.Character {\n    ultCharge = 0;\n    keywords = [\"reduce_massive_damage\"];\n    receiveDamage(damageType, damageAmount, armorPen, critChance, critDamage, stats) {\n        return super.receiveDamage(damageType, damageAmount * 0.7, armorPen, critChance, critDamage, stats);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GRANDMASTERLUKE);\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/character.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/HANSOLO.ts":
/*!**********************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/HANSOLO.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/gameEngine/characters/abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n\n\nclass basicskill_HANSOLO extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"basicskill_HANSOLO\", \"Quick Draw\", `Deal Physical damage to target enemy. If the target has less than 50% Turn Meter, deal 75% more damage. Otherwise, remove 35% Turn Meter. This attack can't be Evaded.`, character);\n    }\n    execute(targetCharacter, stats, canBeCountered, additionalEffects = () => { }) {\n        const primaryTarget = this.findRandomEnemy(targetCharacter, !!targetCharacter);\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            additionalEffects();\n            //note: Cannot be evaded so no evade check\n            if (primaryTarget) {\n                if (primaryTarget.turnMeter < 50) {\n                    this.dealDamage(\"physical\", primaryTarget, 2.6, //1.85 (standard ability modifier) + .75 (additional 75% damage)\n                    5, stats, canBeCountered);\n                }\n                else {\n                    this.dealDamage(\"physical\", primaryTarget, 1.85, 5, stats, canBeCountered);\n                    primaryTarget.changeTurnMeter(-35, this);\n                }\n            }\n        });\n    }\n}\nclass specialskill_HANSOLO01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_HANSOLO01\", \"Deadeye\", `Deal Physical damage to target enemy and Stun them for 1 turn. Gain Turn Meter equal to Han's Critical Chance.`, character);\n        this.cooldown = 3;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy();\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            this._character.changeTurnMeter(this._character.stats.physical.critChance * 100, this);\n            if (primaryTarget) {\n                if (!this.checkEvade(\"physical\", primaryTarget)) {\n                    this._character?.statusEffect.inflictDebuff([{ name: \"Stun\", duration: 1, id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), sourceAbility: this }], primaryTarget, 1, this);\n                    this.dealDamage(\"physical\", primaryTarget, 3.699, 5, stats, canBeCountered);\n                }\n            }\n        });\n    }\n}\nclass specialskill_HANSOLO02 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.ActiveAbility {\n    constructor(character) {\n        super(\"specialskill_HANSOLO02\", \"Never Tell Me the Odds\", `All allies gain Critical Chance Up and Evasion Up for 2 turns. Han gains 50% Turn Meter and Critical Damage Up for 2 turns.`, character);\n        this.cooldown = 4;\n    }\n    execute(targetCharacter, stats, canBeCountered) {\n        const primaryTarget = this.findRandomEnemy();\n        super.execute(primaryTarget, stats, canBeCountered, () => {\n            this._character.changeTurnMeter(50, this);\n            this._character.statusEffect.addBuff({\n                name: \"Critical Damage Up\",\n                duration: 2,\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                sourceAbility: this,\n            }, 1, this);\n            this._character.teammates.forEach((target) => {\n                target.statusEffect.addBuff([\n                    {\n                        name: \"Critical Chance Up\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        sourceAbility: this,\n                    },\n                    {\n                        name: \"Evasion Up\",\n                        duration: 2,\n                        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                        sourceAbility: this,\n                    },\n                ], 1, this);\n            });\n        });\n    }\n}\nclass uniqueskill_HANSOLO01 extends types_gameEngine_characters_abilities__WEBPACK_IMPORTED_MODULE_0__.PassiveAbility {\n    triggerCount = 0;\n    constructor(character) {\n        super(\"uniqueskill_HANSOLO01\", \"Shoots First\", `Han has +35% Counter Chance and +20% Critical Chance. The first time each turn Han uses his Basic attack, he attacks again dealing 50% less damage.\\n\\nHan takes a bonus turn at the start of each encounter. During this turn Han ignores Taunts and he can only use his Basic ability, but it will Stun the target for 1 turn and can't be Resisted.`, character);\n    }\n    activate() {\n        this.triggerCount = 0;\n        this._character?.stats.addTempStats([\n            {\n                statToModify: \"counterChance\",\n                amount: 0.35,\n                modifiedType: \"additive\",\n            },\n            {\n                statToModify: \"physicalCritChance\",\n                amount: 0.2,\n                modifiedType: \"additive\",\n            },\n            {\n                statToModify: \"specialCritChance\",\n                amount: 0.2,\n                modifiedType: \"additive\",\n            },\n        ], this);\n        this._character?.events.push({\n            characterSourceId: this._character.uniqueId,\n            eventType: \"useAbility\",\n            callback: ({ abilityId, target, canBeCountered }) => {\n                if (abilityId === \"basicskill_HANSOLO\" && this.triggerCount < 1) {\n                    this.triggerCount++;\n                    const ability = this._character.activeAbilities.find((x) => x.id === \"basicskill_HANSOLO\");\n                    ability?.execute(target, [\n                        {\n                            statToModify: \"physicalOffense\",\n                            amount: 0.5,\n                            modifiedType: \"multiplicative\",\n                        },\n                        {\n                            statToModify: \"specialOffense\",\n                            amount: 0.5,\n                            modifiedType: \"multiplicative\",\n                        },\n                    ], canBeCountered);\n                }\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"endOfTurn\",\n            callback: () => {\n                this.triggerCount = 0;\n            },\n        }, {\n            characterSourceId: this._character.uniqueId,\n            eventType: \"matchStart\",\n            callback: () => {\n                const ability = this._character.chooseAbility(\"basicskill_HANSOLO\");\n                const primaryTarget = this.findRandomEnemy(undefined, true);\n                if (primaryTarget) {\n                    ability?.execute(primaryTarget, [], true, () => {\n                        this._character.statusEffect.inflictDebuff([\n                            {\n                                name: \"Stun\",\n                                duration: 1,\n                                id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n                                cantResist: true,\n                                sourceAbility: this,\n                            },\n                        ], primaryTarget, 1, this);\n                    });\n                }\n            },\n        });\n    }\n}\nconst basicAbility = new Map([[\"basicskill_HANSOLO\", basicskill_HANSOLO]]);\nconst specialAbilities = new Map([\n    [\"specialskill_HANSOLO01\", specialskill_HANSOLO01],\n    [\"specialskill_HANSOLO02\", specialskill_HANSOLO02],\n]);\nconst uniqueAbilities = new Map([\n    [\"uniqueskill_HANSOLO01\", uniqueskill_HANSOLO01],\n]);\nconst leaderAbility = new Map([]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    specialAbilities,\n    uniqueAbilities,\n    basicAbility,\n    leaderAbility,\n});\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/HANSOLO.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/abilitiesList.ts":
/*!****************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/abilitiesList.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abilitiesList: () => (/* binding */ abilitiesList)\n/* harmony export */ });\n/* harmony import */ var _C3POCHEWBACCA__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./C3POCHEWBACCA */ \"./src/types/gameEngine/characterScripts/C3POCHEWBACCA.ts\");\n/* harmony import */ var _C3POLEGENDARY__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./C3POLEGENDARY */ \"./src/types/gameEngine/characterScripts/C3POLEGENDARY.ts\");\n/* harmony import */ var _CHEWBACCALEGENDARY__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CHEWBACCALEGENDARY */ \"./src/types/gameEngine/characterScripts/CHEWBACCALEGENDARY.ts\");\n/* harmony import */ var _COMMANDERLUKESKYWALKER__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./COMMANDERLUKESKYWALKER */ \"./src/types/gameEngine/characterScripts/COMMANDERLUKESKYWALKER.ts\");\n/* harmony import */ var _HANSOLO__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HANSOLO */ \"./src/types/gameEngine/characterScripts/HANSOLO.ts\");\n/* harmony import */ var _GRANDMASTERLUKE_abilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GRANDMASTERLUKE/abilities */ \"./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/abilities.ts\");\n/* harmony import */ var _GENERALSKYWALKER_abilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GENERALSKYWALKER/abilities */ \"./src/types/gameEngine/characterScripts/GENERALSKYWALKER/abilities.ts\");\n\n\n\n\n\n\n\nconst abilitiesList = {\n    C3POCHEWBACCA: _C3POCHEWBACCA__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    C3POLEGENDARY: _C3POLEGENDARY__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    CHEWBACCALEGENDARY: _CHEWBACCALEGENDARY__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    COMMANDERLUKESKYWALKER: _COMMANDERLUKESKYWALKER__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    HANSOLO: _HANSOLO__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    GRANDMASTERLUKE: _GRANDMASTERLUKE_abilities__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n    GENERALSKYWALKER: _GENERALSKYWALKER_abilities__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n};\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/abilitiesList.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characterScripts/charactersList.ts":
/*!*****************************************************************!*\
  !*** ./src/types/gameEngine/characterScripts/charactersList.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GRANDMASTERLUKE_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GRANDMASTERLUKE/character */ \"./src/types/gameEngine/characterScripts/GRANDMASTERLUKE/character.ts\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Map([\n    [\"GRANDMASTERLUKE\", _GRANDMASTERLUKE_character__WEBPACK_IMPORTED_MODULE_0__[\"default\"]],\n    // [\"GENERALSKYWALKER\", GENERALSKYWALKER],\n]));\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characterScripts/charactersList.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characters/abilities.ts":
/*!******************************************************!*\
  !*** ./src/types/gameEngine/characters/abilities.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ability: () => (/* binding */ Ability),\n/* harmony export */   ActiveAbility: () => (/* binding */ ActiveAbility),\n/* harmony export */   HealthSteal: () => (/* binding */ HealthSteal),\n/* harmony export */   PassiveAbility: () => (/* binding */ PassiveAbility)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/types/gameEngine/characters/utils.ts\");\n\n\n\n/**\n * A generic abstract class for any type of ability\n */\nclass Ability {\n    id;\n    name;\n    text;\n    _character;\n    constructor(id, name, text, parentCharacter) {\n        this.id = id;\n        this.name = name;\n        this.text = text;\n        this._character = parentCharacter;\n    }\n    sanitize() {\n        return { id: this.id, name: this.name, text: this.text };\n    }\n}\n/**\n * A generic abstract class for any type of ability that can exist on a character\n * @abstract @class CharacterAbility\n * @extends Ability\n */\nclass CharacterAbility extends Ability {\n    constructor(id, name, text, parentCharacter) {\n        super(id, name, text, parentCharacter);\n    }\n    /**\n     * Finds a valid target from the provided list with the ability to ignore certain effects (like taunt)\n     * @param validTargets - A List of all the valid targets to select from\n     * @param forcedTarget - The target that must be selected, if able\n     * @param include - A configuration to ignore certain effects\n     * @returns The character target or null if no valid targets exist\n     */\n    findTargets(validTargets, forcedTarget, ignore = { taunt: false, stealth: false, death: false }) {\n        if (forcedTarget && (!forcedTarget.isDead || ignore.death)) {\n            if (forcedTarget.owner === this._character.owner) {\n                return forcedTarget;\n            }\n            else {\n                const tauntingAllies = forcedTarget.teammates.filter((ally) => ally.hasTauntEffect);\n                if (tauntingAllies.length > 0 && !ignore.taunt) {\n                    const randIndex = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, tauntingAllies.length - 1);\n                    return tauntingAllies[randIndex];\n                }\n                if (forcedTarget.statusEffect.hasBuff(\"Stealth\") && !ignore.stealth) {\n                    const alliesWithOutStealth = forcedTarget.teammates.filter((ally) => {\n                        return !ally.statusEffect.hasBuff(\"Stealth\");\n                    });\n                    if (alliesWithOutStealth.length > 0) {\n                        const randIndex = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, alliesWithOutStealth.length - 1);\n                        return alliesWithOutStealth[randIndex];\n                    }\n                }\n            }\n            return forcedTarget;\n        }\n        if (validTargets.length > 0) {\n            const targetList = validTargets.filter((target) => {\n                if (target.isDead) {\n                    return ignore.death;\n                }\n                return true;\n            });\n            const randIndex = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, targetList.length - 1);\n            return targetList[randIndex];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Finds a random enemy to target\n     * @param forcedTarget - The target that must be selected, if able\n     * @param ignoreTaunt - If true, ignores the taunt effects and can select any valid enemy\n     * @returns The character target or null if no valid targets exist\n     */\n    findRandomEnemy(forcedTarget, ignoreTaunt) {\n        return this.findTargets(this._character.opponents.filter((c) => !c.statusEffect.isImmune(\"Targeting\")), forcedTarget, {\n            taunt: ignoreTaunt ?? this._character.effects.ignoreTaunt,\n        });\n    }\n    /**\n     * Finds a random ally to target\n     * @param forcedTarget - The target that must be selected, if able\n     * @returns The character target or null if no valid targets exist\n     */\n    findRandomAlly(forcedTarget) {\n        return this.findTargets(this._character.teammates.filter((ally) => !this._character.isSelf(ally)), forcedTarget, {\n            taunt: true,\n            stealth: true,\n        });\n    }\n    /** Deals damage to a target\n     * @param damageType - The type of damage being dealt (physical, special, or true)\n     * @param targetCharacter - The character to receive the damage\n     * @param abilityModifier - The modifier for the specific ability which will be multplied by the variance to determine the amount of damage dealt\n     * @param variance - The amount of variance that the damage can be\n     * @param stats - An array of stats to modify the starting stat value\n     * @param srcAbility - The optional ability that is causing the damage\n     */\n    dealDamage(damageType, targetCharacter, abilityModifier = 0, variance = 5, stats, canBeCountered, srcAbility) {\n        if (targetCharacter.isDead) {\n            return;\n        }\n        const { offense, critChance, armorPen } = this._character.stats.getCombatStats(damageType, stats);\n        const varianceOffense = damageType === \"true\"\n            ? 1\n            : offense * (1 - (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0 - variance, variance) / 100);\n        const { isCrit, damageTotal } = targetCharacter.receiveDamage(damageType, varianceOffense * abilityModifier, armorPen, critChance, this._character.stats.critDamage, stats);\n        this._character.gameEngine.addLogs([\n            {\n                targetLogData: targetCharacter.getLogs(),\n                damage: {\n                    amount: lodash__WEBPACK_IMPORTED_MODULE_0___default().round(damageTotal, 0),\n                    isCrit,\n                },\n                ability: { source: srcAbility?.sanitize() },\n            },\n        ]);\n        this._character.heal({\n            amountType: \"additive\",\n            amount: damageTotal * this._character.stats.healthSteal,\n            healthType: \"health\",\n        }, new HealthSteal(this._character));\n        this._character?.checkDeath(targetCharacter);\n        this._character.dispatchEvent(\"dealDamage\", {\n            damageAmount: damageTotal,\n            isCrit,\n            damageType,\n            target: targetCharacter,\n        });\n        targetCharacter.dispatchEvent(\"receiveDamage\", {\n            damageAmount: damageTotal,\n            isCrit,\n            damageType,\n            attackSource: this.id,\n        });\n        targetCharacter.counterAttack(this._character, canBeCountered);\n    }\n}\n/**\n * A generic abstract class for any type of ability can be activated (such as basic or special abilities)\n * @abstract @class ActiveAbility\n * @extends CharacterAbility\n */\nclass ActiveAbility extends CharacterAbility {\n    turnsRemaining = null;\n    cooldown = null;\n    constructor(id, name, text, parentCharacter) {\n        super(id, name, text, parentCharacter);\n    }\n    /** Determines if this ability can be used */\n    get canBeUsed() {\n        return true;\n    }\n    /** Initializes the ability */\n    initialize() {\n        if (this.cooldown) {\n            this.turnsRemaining = 0;\n        }\n    }\n    /** Executes all the effects of the ability\n     * @param targetCharacter - The character that the ability is affecting\n     * @param stats - A list of stats what will affect the results of the ability (such as damage)\n     * @param canBeCountered - Determines if the ability can be countered or not\n     * @param additionalEffects - A callback funtion on any additional effects that should be ran\n     */\n    execute(targetCharacter, stats, canBeCountered, additionalEffects = () => { }) {\n        if (targetCharacter) {\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                ability: { used: this.sanitize() },\n            });\n            this._character.dispatchEvent(\"beforeUseAbility\", {\n                abilityId: this.id,\n                target: targetCharacter,\n            });\n            additionalEffects();\n            if (this.cooldown) {\n                this.turnsRemaining = this.cooldown;\n            }\n            this._character.dispatchEvent(\"useAbility\", {\n                abilityId: this.id,\n                target: targetCharacter,\n                canBeCountered,\n            });\n        }\n        else {\n            console.error(\"Could not find a valid target for \", this.id);\n        }\n    }\n    /** Checks if the effect should be evaded\n     * @param damageType - Used to determine if physical or special stats should be used\n     * @param targetCharacter - The character that is the target for the attack\n     * @param stats - A list of stats what will affect the results of the ability (such as damage)\n     * @returns True if the effect is evaded, false if it is not evaded\n     */\n    checkEvade(damageType, targetCharacter, stats) {\n        if (this._character?.isSelf(targetCharacter)) {\n            return false;\n        }\n        else if (this._character) {\n            const { dodge } = targetCharacter.stats.getCombatStats(damageType, stats);\n            const { accuracy } = this._character.stats.getCombatStats(damageType, stats);\n            const attackMissed = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.chanceOfEvent)(dodge - accuracy * 100);\n            if (attackMissed) {\n                this._character.gameEngine.addLogs({\n                    characterLogData: targetCharacter.getLogs(),\n                    damage: { evaded: true },\n                });\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Change an ability's cooldown\n     * @param amount - The amount that the cooldown should be manipulated (negative number decreases the cooldown, positive number increases the cooldown)\n     * @param srcAbility - The source ability that is causing the cooldown change\n     * @param srcCharacter - The Character that is causing the cooldown change\n     * @param cantResist - The effect cannot be resisted\n     */\n    changeCooldown(amount, srcAbility, srcCharacter, cantResist) {\n        if (this.turnsRemaining === null) {\n            return;\n        }\n        const name = amount > 0 ? \"Cooldown Increase\" : \"Cooldown Decrease\";\n        if (this._character?.statusEffect.isImmune({\n            name,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n            duration: amount,\n            sourceAbility: srcAbility,\n        })) {\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                statusEffects: {\n                    immune: true,\n                    type: amount > 0 ? \"debuff\" : \"buff\",\n                    list: [\n                        { name, duration: amount, sourceAbility: srcAbility.sanitize() },\n                    ],\n                },\n            });\n        }\n        else {\n            if (amount > 0 && !!srcCharacter) {\n                const resistedChance = Math.max((this._character?.stats.tenacity ?? 0) - srcCharacter?.stats.potency, 0.15);\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.chanceOfEvent)(resistedChance) && !cantResist) {\n                    this._character.gameEngine.addLogs({\n                        characterLogData: this._character.getLogs(),\n                        statusEffects: {\n                            resisted: true,\n                            list: [\n                                { name, duration: 0, sourceAbility: srcAbility.sanitize() },\n                            ],\n                            type: \"debuff\",\n                        },\n                    });\n                    this._character?.dispatchEvent(\"resisted\", {\n                        effect: \"Cooldown Increase\",\n                    });\n                    return;\n                }\n            }\n            let finalAmount = amount;\n            if (amount < 0) {\n                if (this.turnsRemaining <= 0) {\n                    return;\n                }\n                finalAmount = Math.max(amount, 0 - this.turnsRemaining);\n            }\n            this.turnsRemaining += finalAmount;\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                ability: { source: srcAbility.sanitize() },\n                effects: {\n                    cooldown: { ability: this.sanitize(), amount: finalAmount },\n                },\n            });\n        }\n    }\n}\n/**\n * A generic abstract class for any type of ability is passive and cannot be activated (such as unique or leader)\n * @abstract @class PassiveAbility\n * @extends CharacterAbility\n */\nclass PassiveAbility extends CharacterAbility {\n    constructor(id, name, text, parentCharacter) {\n        super(id, name, text, parentCharacter);\n    }\n    /** Applies all of the given events, stat increases, and other effects */\n    activate() { }\n    /** Removes all of the given events, stat increases, and other effects from all teammates and opponents */\n    deactivate() {\n        this._character?.teammates.forEach((target) => {\n            target.events = target.events.filter((event) => {\n                return event.characterSourceId !== this._character?.uniqueId;\n            });\n            target.stats.removeTempStats(this._character?.uniqueId);\n        });\n        this._character?.opponents.forEach((target) => {\n            target.events = target.events.filter((event) => {\n                return event.characterSourceId !== this._character?.uniqueId;\n            });\n            target.stats.removeTempStats(this._character?.uniqueId);\n        });\n    }\n}\n/**\n * A class specifically used for the Health Steal mechanic when dealing damage\n * @class PassiveAbility\n * @extends CharacterAbility\n */\nclass HealthSteal extends Ability {\n    constructor(character) {\n        super(\"healthSteal\", \"Health Steal\", \"The percentage amount of the damage that this character heals whenever they deal damage.\", character);\n    }\n}\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characters/abilities.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characters/index.ts":
/*!**************************************************!*\
  !*** ./src/types/gameEngine/characters/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* binding */ Character),\n/* harmony export */   anyTagsMatch: () => (/* binding */ anyTagsMatch)\n/* harmony export */ });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/types/gameEngine/characters/utils.ts\");\n/* harmony import */ var _stats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stats */ \"./src/types/gameEngine/characters/stats.ts\");\n/* harmony import */ var _statusEffects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./statusEffects */ \"./src/types/gameEngine/characters/statusEffects.ts\");\n/* harmony import */ var _characterScripts_abilitiesList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../characterScripts/abilitiesList */ \"./src/types/gameEngine/characterScripts/abilitiesList.ts\");\n\n\n\n\n\n/**\n * A Character, otherwise known as unit or toon, that can have abilities and affect the flow of the game\n * @class Character\n */\nclass Character {\n    stats;\n    statusEffect;\n    id;\n    name;\n    _tm = 0;\n    relicLevel = 0;\n    _basicAbility = null;\n    _specialAbilities = [];\n    _hiddenAbilities = [];\n    _uniqueAbilities = [];\n    _leaderAbility = null;\n    owner;\n    _alignment;\n    _categories;\n    teammates = [];\n    opponents = [];\n    isLeader = false;\n    events = [];\n    keywords = [];\n    hasBonusTurn = false;\n    gameEngine;\n    constructor(data, owner, isLeader, gameEngine) {\n        this.gameEngine = gameEngine;\n        this.stats = new _stats__WEBPACK_IMPORTED_MODULE_2__.Stats(data, this);\n        this.statusEffect = new _statusEffects__WEBPACK_IMPORTED_MODULE_3__.StatusEffect(this);\n        this.name = data.name;\n        this.id = data.id;\n        this.owner = owner;\n        this._alignment = data.alignment;\n        this._categories = data.categories;\n        this.isLeader = isLeader ?? false;\n        this.relicLevel = data.relic_tier ?? 0;\n        const abilityList = _characterScripts_abilitiesList__WEBPACK_IMPORTED_MODULE_4__.abilitiesList[this.id];\n        data.ability_data.forEach((x) => {\n            if (x.id.includes(\"basic\")) {\n                const abilityClass = abilityList.basicAbility.get(x.id);\n                if (abilityClass) {\n                    this._basicAbility = new abilityClass(this);\n                }\n            }\n            else if (x.id.includes(\"special\")) {\n                const abilityClass = abilityList.specialAbilities.get(x.id);\n                if (abilityClass) {\n                    this._specialAbilities.push(new abilityClass(this));\n                }\n            }\n            else if (x.id.includes(\"unique\")) {\n                const abilityClass = abilityList.uniqueAbilities.get(x.id);\n                if (abilityClass) {\n                    this._uniqueAbilities.push(new abilityClass(this));\n                }\n            }\n            else if (x.id.includes(\"leader\")) {\n                const abilityClass = abilityList.leaderAbility.get(x.id);\n                if (abilityClass) {\n                    this._leaderAbility = new abilityClass(this);\n                }\n            }\n        });\n    }\n    /** A unique identifier based on the character id and owner */\n    get uniqueId() {\n        return this.id + this.owner;\n    }\n    /** Checks if the provided character is the same as this character */\n    isSelf(char) {\n        return this.id === char?.id && this.owner === char?.owner;\n    }\n    /** The character's basic ability */\n    get basicAbility() {\n        return this._basicAbility;\n    }\n    /** The character's special abilities */\n    get specialAbilities() {\n        return this._specialAbilities;\n    }\n    /** The character's hidden abilities */\n    get hiddenAbilities() {\n        return this._hiddenAbilities;\n    }\n    /** A list of abilities including the basic ability and specials */\n    get activeAbilities() {\n        const arr = [];\n        if (this._basicAbility) {\n            arr.push(this._basicAbility);\n        }\n        arr.push(...this._specialAbilities);\n        return arr;\n    }\n    /** A list of unique abilities */\n    get uniqueAbilities() {\n        return this._uniqueAbilities;\n    }\n    /** Adds a new granted ability */\n    addGrantedAbility(ability) {\n        this._specialAbilities.push(ability);\n    }\n    /** A map of different effects that may exist on the character */\n    get effects() {\n        const self = this;\n        return {\n            get ignoreTaunt() {\n                return (self.statusEffect.hasBuff(\"Call to Action\") ||\n                    self.statusEffect.hasBuff(\"Jedi Legacy\"));\n            },\n        };\n    }\n    /* How much turn meter the character currently has */\n    get turnMeter() {\n        return this._tm;\n    }\n    /* The ratio of turn meter. Used to compare to other characters' turn meter ratio to determine who goes next */\n    get turnMeterRatio() {\n        return (100 - this._tm) / this.stats.speed;\n    }\n    /** Manipulates the unit's turn meter by a certain amount\n     * @param amount - The amount the turn meter will be changed. Positive number will add turn meter, negative number will remove turn meter\n     * @param srcAbility - The ability source that is causing the turn meter to change\n     * @param srcCharacter - The character that is causing the turn meter to change\n     */\n    changeTurnMeter(amount, srcAbility, srcCharacter) {\n        if (amount === 0 || this.isDead) {\n            return;\n        }\n        let diff = 0;\n        if (this._tm >= 100 && amount < 0) {\n            const resistedChance = Math.max(this.stats.tenacity - (srcCharacter?.stats.potency ?? 0), 0.15);\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.chanceOfEvent)(resistedChance)) {\n                this.gameEngine.addLogs({\n                    characterLogData: this.getLogs(),\n                    statusEffects: {\n                        resisted: true,\n                        list: [\n                            {\n                                name: \"TM Decrease\",\n                                duration: amount,\n                                sourceAbility: srcAbility?.sanitize(),\n                            },\n                        ],\n                        type: \"debuff\",\n                    },\n                });\n                this.dispatchEvent(\"resisted\", { effect: \"TM Decrease\" });\n                return;\n            }\n            diff = Math.abs(amount);\n            this._tm = 100 + amount; //note this will remove tm since amount is a negative number\n        }\n        else {\n            diff = amount < 0 ? Math.min(Math.abs(amount), this._tm) : amount;\n            this._tm += amount;\n        }\n        if (this._tm < 0) {\n            this._tm = 0;\n        }\n        if (srcAbility) {\n            this.gameEngine.addLogs({\n                characterLogData: this.getLogs(),\n                effects: {\n                    turnMeter: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(amount > 0 ? diff : 0 - diff, 2),\n                },\n                ability: {\n                    source: srcAbility.sanitize(),\n                },\n            });\n        }\n    }\n    /**\n     * A utility function to determine who's turn meter is higher: This character or the provided opponent\n     * @param opponent - The opponent to compare turn meter to\n     * @returns An object containing the character who's turm meter is higher (either this character or the provided opponent) and the amount of turn meter that is gained\n     */\n    compareTm(opponent) {\n        const results = {\n            character: this,\n            amount: 0,\n        };\n        if (opponent.turnMeter >= 100 && this.turnMeter >= 100) {\n            results.amount = 0;\n            if (opponent.turnMeter > this.turnMeter) {\n                results.character = opponent;\n            }\n            else if (opponent.turnMeter === this.turnMeter) {\n                if (opponent.stats.speed > this.stats.speed) {\n                    results.character = opponent;\n                }\n                else if (this.stats.speed === opponent.stats.speed) {\n                    const rand = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, 1);\n                    if (rand === 1) {\n                        results.character = opponent;\n                    }\n                }\n            }\n        }\n        else if (this.turnMeterRatio < opponent.turnMeterRatio) {\n            results.amount = 100 - this.turnMeter;\n            results.character = this;\n        }\n        else if (opponent.turnMeterRatio < this.turnMeterRatio) {\n            results.amount = 100 - opponent.turnMeter;\n            results.character = opponent;\n        }\n        else {\n            const rand = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, 1);\n            const c = rand === 0 ? this : opponent;\n            results.amount = 100 - c.turnMeter;\n            results.character = c;\n        }\n        return results;\n    }\n    /**\n     * Resets all abilities, stats, and other effects\n     * @param teammates - A list of characters that are this character's teammates\n     * @param opponents - A list of characters that are this character's opponents\n     */\n    reset(teammates, opponents) {\n        this.teammates = teammates;\n        this.opponents = opponents;\n        this._uniqueAbilities.forEach((a) => a.deactivate());\n        this._leaderAbility?.deactivate();\n        this.stats.reset();\n        this.statusEffect.reset();\n    }\n    /**\n     * An initializer function that resets various properties and applies passive abilities\n     */\n    initialize() {\n        this.stats.initialize();\n        this._specialAbilities.forEach((ability) => {\n            ability.initialize();\n        });\n        this._uniqueAbilities.forEach((ability) => {\n            ability.activate();\n        });\n        if (this.isLeader) {\n            this._leaderAbility?.activate();\n        }\n        this.statusEffect.initialize();\n        this._tm = 0;\n    }\n    /** Is the character's health at 0 or less */\n    get isDead() {\n        return this.stats.health <= 0;\n    }\n    /** Checks if the character is dead and if so removes any related effects\n     * @param targetCharacter - Checks if the character is dead and removes any effects\n     */\n    checkDeath(targetCharacter) {\n        if (targetCharacter.isDead) {\n            this.gameEngine.addLogs({\n                characterLogData: this.getLogs(),\n                targetLogData: targetCharacter.getLogs(),\n                effects: { defeated: true },\n            });\n            targetCharacter._uniqueAbilities.forEach((a) => a.deactivate());\n            targetCharacter.dispatchEvent(\"death\");\n        }\n    }\n    /** Does the character have any effect that is forcing them to be targeted */\n    get hasTauntEffect() {\n        return (this.statusEffect.hasBuff(\"Taunt\") ||\n            this.statusEffect.hasDebuff([\"Marked\", \"Deathmark\"]));\n    }\n    /** The character takes an action and uses an ability if possible */\n    takeAction() {\n        this.startOfTurn();\n        this._tm = 0;\n        let ability = null;\n        if (this.statusEffect.hasDebuff(\"Stun\")) {\n            this.gameEngine.addLogs({\n                characterLogData: this.getLogs(),\n                effects: { stunned: true },\n            });\n        }\n        else {\n            ability = this.chooseAbility();\n            ability?.execute();\n        }\n        this.endOfTurn(ability);\n    }\n    /** Triggers any effects at the start of the turn */\n    startOfTurn() {\n        this.statusEffect.debuffs.forEach((debuff) => {\n            debuff.isNew = false;\n        });\n        this.statusEffect.buffs.forEach((debuff) => {\n            debuff.isNew = false;\n        });\n        this.dispatchEvent(\"startOfTurn\", {\n            characterId: this.id,\n            owner: this.owner,\n        });\n    }\n    /**\n     * Triggers all end of turn effects and resets various pieces of data\n     * @param ability - The ability that was used on the turn\n     */\n    endOfTurn(ability) {\n        this.statusEffect.endOfTurn();\n        this.stats.endOfTurn();\n        this._specialAbilities.forEach((a) => {\n            if (ability?.id !== a.id && a.turnsRemaining !== null) {\n                a.turnsRemaining = Math.max(a.turnsRemaining - 1, 0);\n            }\n        });\n        this.hasBonusTurn = false;\n    }\n    /**\n     * Picks an ability that is able to be used\n     * @param abilityId - The ability ID that must be used if able\n     * @returns An ability that can be used\n     */\n    chooseAbility(abilityId) {\n        if (this.statusEffect.hasDebuff(\"Stun\")) {\n            return null;\n        }\n        else if (this.statusEffect.hasDebuff(\"Ability Block\")) {\n            return this._basicAbility;\n        }\n        else if (abilityId === this._basicAbility?.id) {\n            return this._basicAbility;\n        }\n        else if (this._specialAbilities.every((a) => (a.turnsRemaining !== null && a.turnsRemaining > 0) || !a.canBeUsed)) {\n            return this._basicAbility;\n        }\n        const ability = this._specialAbilities.find((a) => {\n            if (abilityId) {\n                return a.id === abilityId;\n            }\n            else {\n                return (a.turnsRemaining !== null && a.turnsRemaining <= 0 && a.canBeUsed);\n            }\n        });\n        return ability ?? null;\n    }\n    /** Checks if the user has any leader abilities */\n    get hasLeaderAbility() {\n        return !!this._leaderAbility;\n    }\n    /** Gets the leader ability */\n    get leaderAbility() {\n        return this.leaderAbility;\n    }\n    /** Assists with their basic attack\n     * @param modifiers - A list of stats to change the outcome of the damage\n     * @param targetCharacter - The character in which is being attacked\n     * @param srcAbility - The ability source that is calling the assist\n     */\n    assist(modifiers, targetCharacter, srcAbility) {\n        if (this._basicAbility && !targetCharacter?.isDead) {\n            if (this.statusEffect.isImmune(\"Assisting\")) {\n                this.gameEngine.addLogs({\n                    characterLogData: this.getLogs(),\n                    effects: { assisted: false },\n                    ability: {\n                        source: this.statusEffect.immunity.Assisting.sourceAbility?.sanitize(),\n                    },\n                });\n            }\n            else {\n                this.gameEngine.addLogs({\n                    characterLogData: this.getLogs(),\n                    effects: { assisted: true },\n                    ability: { source: srcAbility?.sanitize() },\n                });\n                this._basicAbility.execute(targetCharacter, modifiers, false);\n            }\n        }\n    }\n    /** Heals the character for a determined amount of health or protection\n     * @param healData - The data that determines how much and what type of healing to do\n     * @param sourceAbility - The ability that has the heal effect\n     * @param amountSource - The source value when healing a multiplicative amount (defaults to max value)\n     */\n    heal(healData, sourceAbility, amountSource) {\n        if (healData && !this.isDead) {\n            const { healthType, amountType, amount } = healData;\n            if (!amountSource) {\n                amountSource =\n                    healthType === \"health\"\n                        ? this.stats.maxHealth\n                        : this.stats.maxProtection;\n            }\n            const maxStat = healthType === \"health\"\n                ? this.stats.maxHealth\n                : this.stats.maxProtection;\n            const finalAmount = amountType === \"multiplicative\"\n                ? (amount ?? 1) * amountSource\n                : amount ?? 0;\n            let diff = 0;\n            if (this.stats[healthType] + finalAmount > maxStat) {\n                diff = maxStat - this.stats[healthType];\n            }\n            else {\n                diff = finalAmount;\n            }\n            this.stats.gainHealth(finalAmount, healthType);\n            if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(diff) > 0) {\n                this.gameEngine.addLogs({\n                    characterLogData: this.getLogs(),\n                    heal: { amount: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(diff), type: healthType },\n                    ability: { source: sourceAbility?.sanitize() },\n                });\n            }\n        }\n    }\n    /**\n     * Counter attacks, using the character's basic ability if able\n     * @param targetCharacter - The target character that is being attacked\n     * @param canBeCountered - Determines if this character is allowed to counter attack\n     */\n    counterAttack(targetCharacter, canBeCountered) {\n        if (canBeCountered !== false && !targetCharacter.isDead) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.chanceOfEvent)(this.stats.counterChance * 100) &&\n                !this.isDead &&\n                this.owner !== targetCharacter.owner) {\n                if (this.statusEffect.isImmune(\"CounterAttacking\")) {\n                    this.gameEngine.addLogs({\n                        characterLogData: this.getLogs(),\n                        effects: { countered: false },\n                        ability: {\n                            source: this.statusEffect.immunity.CounterAttacking.sourceAbility?.sanitize(),\n                        },\n                    });\n                }\n                else {\n                    this.gameEngine.addLogs({\n                        characterLogData: this.getLogs(),\n                        effects: { countered: true },\n                    });\n                    this._basicAbility?.execute(targetCharacter, [\n                        {\n                            statToModify: \"physicalOffense\",\n                            amount: this.stats.counterDamage,\n                            modifiedType: \"multiplicative\",\n                        },\n                        {\n                            statToModify: \"specialOffense\",\n                            amount: this.stats.counterDamage,\n                            modifiedType: \"multiplicative\",\n                        },\n                    ], false);\n                }\n            }\n        }\n    }\n    /** Recieves damage mitigated by armor\n     * @param damageType - The type of damage being dealt (physical, special, or true)\n     * @param damageAmount - The amount of damage being dealt (before armor or other reductions)\n     * @param armorPen - The amount of armor that is ignored (armor penetration)\n     * @param critChance - The chance of receving a critical hit\n     * @param critDamage - The amount to be modified on a critical hit (decimal)\n     * @param stats - An array of stats to modify the starting stat value\n     */\n    receiveDamage(damageType, damageAmount, armorPen, critChance, critDamage, stats) {\n        if (this.isDead) {\n            return { isCrit: false, damageTotal: 0 };\n        }\n        else if (damageType === \"true\") {\n            this.stats.loseHealth(damageAmount);\n            return { isCrit: false, damageTotal: damageAmount };\n        }\n        else {\n            const { armor, critAvoid } = this.stats.getCombatStats(damageType, stats);\n            const modifiedArmor = Math.max(armor - armorPen, 0);\n            const damageReduction = (modifiedArmor * 100) / (modifiedArmor + 637.5) / 100;\n            const damageTaken = damageAmount * (1 - damageReduction);\n            const isCrit = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.chanceOfEvent)((critChance - critAvoid) * 100);\n            const damageTotal = Math.max(Math.round(damageTaken * (isCrit ? critDamage : 1)), 1);\n            this.stats.loseHealth(damageTotal);\n            return { isCrit, damageTotal };\n        }\n    }\n    /**\n     * Revives the character with a certain amount of protection and health\n     * @param protection - The amount of protection that should be set as the current amount\n     * @param health - The amount of health that should be set as the current amount\n     */\n    revive(protection, health) {\n        if (this.isDead && !this.statusEffect.isImmune(\"Revive\")) {\n            this.initialize();\n            this.stats.gainHealth(protection, \"protection\");\n            this.stats.gainHealth(health, \"health\");\n            this.gameEngine.addLogs({\n                characterLogData: this.getLogs(),\n                effects: { revived: true },\n            });\n            this.dispatchEvent(\"revive\", { target: this });\n        }\n    }\n    /**\n     * Triggers any events on the character that matches a particular event type\n     * @param eventType - The type of event that should be triggered\n     * @param context - Additional data that can be used to pass down to the event\n     */\n    dispatchEvent(eventType, context) {\n        this.events.forEach((event) => {\n            if (event.eventType === eventType) {\n                event.callback(context);\n            }\n        });\n    }\n    /**\n     * Checks whether a condition is true\n     * @param condition - A function to be ran when a condition should be checked\n     * @returns True if the condition has been met, otherwise false\n     */\n    checkCondition(condition) {\n        if (!condition) {\n            return true;\n        }\n        else {\n            return condition();\n        }\n    }\n    /**\n     * Checks whether the character has any of the provided tags (including character id, categories, or alignment)\n     * @param tag - The string used to check\n     * @param id - The id used to check if this is the same as this character's id\n     * @returns true if this character has the tag or has otherwise been met\n     */\n    hasTags(tag, id) {\n        if (this._categories.includes(tag)) {\n            return true;\n        }\n        else if (tag === \"Self\") {\n            return this.id === id;\n        }\n        else if (tag === \"Light Side\" ||\n            tag === \"Dark Side\" ||\n            tag === \"Neutral\") {\n            return this._alignment === tag;\n        }\n        else {\n            return tag === this.id;\n        }\n    }\n    /**\n     * A utility function used to output the current state of the character stats\n     * @returns A map of various pieces of data used to log out the characters stats\n     */\n    getLogs() {\n        return {\n            name: this.name,\n            owner: this.owner,\n            health: {\n                current: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.health, 0),\n                max: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.maxHealth, 0),\n                base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.maxHealth, 0),\n            },\n            protection: {\n                current: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.protection, 0),\n                max: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.maxProtection, 0),\n                base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.maxProtection, 0),\n                bonus: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.bonusProtection, 0),\n            },\n            activeAbilities: this.activeAbilities.map((a) => {\n                return {\n                    ...a.sanitize(),\n                    cooldown: a.turnsRemaining,\n                };\n            }),\n            buffs: this.statusEffect.buffs.map((buff) => {\n                return {\n                    name: buff.name ?? \"\",\n                    duration: buff.duration,\n                    cantDispel: buff.cantDispel,\n                    cantPrevent: buff.cantPrevent,\n                    cantResist: buff.cantResist,\n                    unique: buff.unique,\n                };\n            }),\n            debuffs: this.statusEffect.debuffs.map((debuff) => {\n                return {\n                    name: debuff.name ?? \"\",\n                    duration: debuff.duration,\n                    cantDispel: debuff.cantDispel,\n                    cantPrevent: debuff.cantPrevent,\n                    cantResist: debuff.cantResist,\n                    unique: debuff.unique,\n                };\n            }),\n            statusEffects: this.statusEffect.statusEffects.map((effect) => {\n                return {\n                    name: effect.name ?? \"\",\n                    duration: effect.duration,\n                    cantDispel: effect.cantDispel,\n                    cantPrevent: effect.cantPrevent,\n                    cantResist: effect.cantResist,\n                    unique: effect.unique,\n                };\n            }),\n            physical: [\n                {\n                    label: \"Offense\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.offense, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.offense, 2),\n                },\n                {\n                    label: \"Crit Chance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.critChance * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.critChance * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Armor\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)((this.stats.physical.armor * 100) /\n                        (this.stats.physical.armor + 637.5), 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)((this.stats.baseStats.physical.armor * 100) /\n                        (this.stats.baseStats.physical.armor + 637.5), 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Armor Pen\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.armorPen, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.armorPen, 2),\n                },\n                {\n                    label: \"Accuracy\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.accuracy * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.accuracy * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Dodge\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.dodge * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.dodge * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Crit Avoidance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.physical.critAvoid * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.physical.critAvoid * 100, 2),\n                    isPercent: true,\n                },\n            ],\n            special: [\n                {\n                    label: \"Offense\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.offense, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.offense, 2),\n                },\n                {\n                    label: \"Crit Chance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.critChance * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.critChance * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Resistance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)((this.stats.special.armor * 100) /\n                        (this.stats.special.armor + 637.5), 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)((this.stats.baseStats.special.armor * 100) /\n                        (this.stats.baseStats.special.armor + 637.5), 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Resistance Pen\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.armorPen, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.armorPen, 2),\n                },\n                {\n                    label: \"Accuracy\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.accuracy * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.accuracy * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Deflection\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.dodge * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.dodge * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Crit Avoidance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.special.critAvoid * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.special.critAvoid * 100, 2),\n                    isPercent: true,\n                },\n            ],\n            general: [\n                {\n                    label: \"Speed\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.speed, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.speed, 2),\n                },\n                {\n                    label: \"Mastery\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.mastery, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.mastery, 2),\n                },\n                {\n                    label: \"Crit Damage\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.critDamage * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.critDamage * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Tenacity\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.tenacity * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.tenacity * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Potency\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.potency * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.potency * 100, 2),\n                    isPercent: true,\n                },\n                {\n                    label: \"Health Steal\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.healthSteal * 100, 2),\n                    base: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.baseStats.healthSteal * 100, 2),\n                    isPercent: true,\n                },\n                // {\n                //   label: \"Defense Pen\",\n                //   value: 0,\n                //   base: 0,\n                //   isPercent: true,\n                // },\n                {\n                    label: \"Counter Chance\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.counterChance * 100, 2),\n                    base: 0,\n                    isPercent: true,\n                },\n                {\n                    label: \"Counter Damage\",\n                    value: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.stats.counterDamage * 100, 2),\n                    base: 100,\n                    isPercent: true,\n                },\n            ],\n            otherEffects: {\n                ...this.effects,\n                immunity: this.statusEffect.sanitizeImmunity(),\n            },\n            turnMeter: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.round)(this.turnMeter, 0),\n        };\n    }\n}\n//todo: combine these functions with /teams.js\n/**\n * Checks if any of the tags provided match with a character. Can use `&` or `!` notation too\n * @param character - The character to check the tags on\n * @param tagsList - The list of tags that should be checked\n * @param id - The ID used to check if its the same as the character\n * @returns True if the tags match, false if they dont\n */\nfunction anyTagsMatch(character, tagsList, id) {\n    return tagsList.some((tag) => {\n        if (tag.includes(\"&\")) {\n            const split = tag.split(\"&\");\n            return split.every((x) => anyTagsMatch(character, [x.trim()], id));\n        }\n        else if (tag.charAt(0) === \"!\") {\n            const value = tag.substring(1);\n            return !character.hasTags(value, id);\n        }\n        else {\n            return character.hasTags(tag, id);\n        }\n    });\n}\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characters/index.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characters/stats.ts":
/*!**************************************************!*\
  !*** ./src/types/gameEngine/characters/stats.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stats: () => (/* binding */ Stats),\n/* harmony export */   modifyStat: () => (/* binding */ modifyStat)\n/* harmony export */ });\n/** A container class used to hold all of a character's status any utility functions */\nclass Stats {\n    baseStats;\n    tempStats = [];\n    _role;\n    _primaryStat;\n    _character;\n    _curHealth = 0;\n    _curProtection = 0;\n    constructor(data, parentCharacter) {\n        const masteryMapping = {\n            0: 0,\n            1: 5,\n            2: 10,\n            3: 15,\n            4: 20,\n            5: 25,\n            6: 35,\n            7: 45,\n            8: 60,\n            9: 70,\n        };\n        this._character = parentCharacter;\n        this._role = data.role;\n        this._primaryStat = data.primaryStat;\n        this.baseStats = {\n            maxHealth: data.stats[\"1\"],\n            health: data.stats[\"1\"],\n            maxProtection: data.stats[\"28\"],\n            protection: data.stats[\"28\"],\n            speed: data.stats[\"5\"],\n            physical: {\n                offense: data.stats[\"6\"],\n                armor: (data.stats[\"8\"] * 637.5) / (100 - data.stats[\"8\"]),\n                armorPen: data.stats[\"10\"],\n                critChance: data.stats[\"14\"] / 100,\n                accuracy: data.stats[\"37\"] / 100,\n                dodge: data.stats[\"12\"] / 100,\n                critAvoid: data.stats[\"39\"] / 100,\n            },\n            special: {\n                offense: data.stats[\"7\"],\n                armor: (data.stats[\"9\"] * 637.5) / (100 - data.stats[\"9\"]),\n                armorPen: data.stats[\"11\"],\n                critChance: data.stats[\"15\"] / 100,\n                accuracy: data.stats[\"38\"] / 100,\n                dodge: data.stats[\"13\"] / 100,\n                critAvoid: data.stats[\"40\"] / 100,\n            },\n            critDamage: data.stats[\"16\"],\n            tenacity: data.stats[\"18\"],\n            potency: data.stats[\"17\"],\n            healthSteal: data.stats[\"27\"],\n            mastery: masteryMapping[data.relic_tier ?? 0],\n        };\n        this._curHealth = data.stats[\"1\"];\n        this._curProtection = data.stats[\"28\"];\n    }\n    /** An initializer function that resets various properties */\n    initialize() {\n        this._curHealth = this.maxHealth;\n        this._curProtection = this.maxProtection;\n    }\n    /** The modified maximum amount of Protection */\n    get maxProtection() {\n        let stat = this.baseStats.maxProtection;\n        if (this._role === \"Tank\") {\n            if (this._primaryStat === \"str\") {\n                stat += 220 * this.mastery;\n            }\n            else if (this._primaryStat === \"agi\") {\n                stat += 200 * this.mastery;\n            }\n            else if (this._primaryStat === \"tac\") {\n                stat += 230 * this.mastery;\n            }\n        }\n        return this.getModifiedStats([], stat, this.getTempStat(\"maxProtection\"));\n    }\n    set maxProtection(val) {\n        this.baseStats.maxProtection = val;\n    }\n    get bonusProtection() {\n        return this._character.statusEffect.buffs.reduce((total, buff) => {\n            if (buff.name === \"Protection Up\") {\n                total += buff.value ?? 0;\n            }\n            return total;\n        }, 0);\n    }\n    /** The modified maximum amount of Health */\n    get maxHealth() {\n        let stat = this.baseStats.maxHealth;\n        if (this._role === \"Tank\") {\n            if (this._primaryStat === \"agi\") {\n                stat += 120 * this.mastery;\n            }\n        }\n        else if (this._role === \"Healer\") {\n            if (this._primaryStat === \"str\") {\n                stat += 420 * this.mastery;\n            }\n            else if (this._primaryStat === \"agi\") {\n                stat += 225 * this.mastery;\n            }\n            else if (this._primaryStat === \"tac\") {\n                stat += 300 * this.mastery;\n            }\n        }\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Health Down\"),\n                value: -0.2,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Health Up\"),\n                value: 0.15,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Translation\", undefined, 1),\n                value: 0.3,\n            },\n        ], stat, this.getTempStat(\"maxHealth\"), true);\n    }\n    set maxHealth(val) {\n        this.baseStats.maxHealth = val;\n    }\n    /** The current amount of Health */\n    get health() {\n        return this._curHealth;\n    }\n    /** The current amount of Protection */\n    get protection() {\n        return this._curProtection;\n    }\n    /**\n     * Calculates how much should be removed from Protection Up, Protection, or Health\n     * @param amount - The amount of health/protection that is lost\n     * @param type - The type of health lost if targeting a specific type (e.g. lose health, ignoring protection)\n     */\n    loseHealth(amount, type) {\n        if (type === \"health\") {\n            if (this._character.statusEffect.isImmune(\"loseHealth\")) {\n                return;\n            }\n            this._curHealth -= amount;\n            this._curHealth = Math.max(this._curHealth, 0);\n            this._character.dispatchEvent(\"loseHealth\", {\n                previousHealth: this._curHealth + amount,\n            });\n        }\n        else if (type === \"protection\") {\n            this._curProtection -= amount;\n            this._curProtection = Math.max(this._curProtection, 0);\n            this._character.dispatchEvent(\"loseProtection\");\n        }\n        else if (this._character.statusEffect.hasBuff(\"Protection Up\")) {\n            const match = this._character.statusEffect.buffs.find((x) => x.name === \"Protection Up\");\n            if (match?.value) {\n                if (match?.value && match?.value > amount) {\n                    match.value -= amount;\n                }\n                else {\n                    const diff = amount - match.value;\n                    match.value = 0;\n                    this.loseHealth(diff);\n                }\n                if (match?.value <= 0) {\n                    this._character.statusEffect.removeBuff({\n                        id: match.id,\n                        duration: 0,\n                        name: null,\n                        sourceAbility: null,\n                    });\n                }\n            }\n        }\n        else if (this._curProtection > 0) {\n            if (this._curProtection > amount) {\n                this._curProtection -= amount;\n                this._character.dispatchEvent(\"loseProtection\");\n            }\n            else {\n                const diff = amount - this._curProtection;\n                this._curProtection = 0;\n                this._character.dispatchEvent(\"loseProtection\");\n                this.loseHealth(diff);\n            }\n        }\n        else {\n            if (this._character.statusEffect.isImmune(\"loseHealth\")) {\n                return;\n            }\n            this._curHealth -= amount;\n            this._character.dispatchEvent(\"loseHealth\", {\n                previousHealth: this._curHealth + amount,\n            });\n        }\n    }\n    /**\n     * Gains health or protection\n     * @param amount - The amount of health/protection that is gained\n     * @param type - The type of health or protection if needing to target a specific type\n     */\n    gainHealth(amount, type) {\n        if (type === \"health\") {\n            this._curHealth += amount;\n            this._curHealth = Math.min(this._curHealth, this.maxHealth);\n        }\n        else if (type === \"protection\") {\n            this._curProtection += amount;\n            this._curProtection = Math.min(this._curProtection, this.maxHealth);\n        }\n        else {\n            this._curHealth += amount;\n            if (this._curHealth > this.maxHealth) {\n                const diff = this._curHealth - this.maxHealth;\n                this._curProtection += diff;\n                this._curHealth = this.maxHealth;\n                if (this._curProtection > this.maxProtection) {\n                    this._curProtection = this.maxProtection;\n                }\n            }\n        }\n    }\n    /** The current Speed */\n    get speed() {\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Speed Down\") ||\n                    this._character.statusEffect.hasDebuff(\"Breach\"),\n                value: -0.25,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Speed Up\"),\n                value: 0.25,\n            },\n        ], this.baseStats.speed, this.getTempStat(\"speed\"), true);\n    }\n    /** The current mastery of the character */\n    get mastery() {\n        let stat = this.baseStats.mastery;\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Jedi Lessons\", undefined, 1),\n                value: 0.2,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Jedi Lessons\", undefined, 2),\n                value: 0.2,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Jedi Lessons\", undefined, 3),\n                value: 0.2,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Jedi Legacy\"),\n                value: 1,\n            },\n        ], stat, this.getTempStat(\"mastery\"), true);\n    }\n    /** The current Critical Damage (decimal) */\n    get critDamage() {\n        let stat = this.baseStats.critDamage;\n        if (this._role === \"Attacker\") {\n            if (this._primaryStat === \"agi\") {\n                stat += 0.003 * this.mastery;\n            }\n        }\n        else if (this._role === \"Support\") {\n            if (this._primaryStat === \"agi\") {\n                stat *= 0.003 * this.mastery;\n            }\n        }\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Call to Action\"),\n                value: 0.5,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Critical Damage Down\"),\n                value: -0.5,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Critical Damage Up\"),\n                value: 0.5,\n            },\n        ], stat, this.getTempStat(\"critDamage\"));\n    }\n    /** The current Tenacity (decimal) */\n    get tenacity() {\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Tenacity Down\"),\n                value: -Infinity,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Tenacity Up\"),\n                value: Infinity,\n            },\n        ], this.baseStats.tenacity, this.getTempStat(\"tenacity\"));\n    }\n    set tenacity(val) {\n        this.baseStats.tenacity = val;\n    }\n    /** The current Potency (decimal) */\n    get potency() {\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Potency Down\"),\n                value: -0.5,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Potency Up\"),\n                value: 0.5,\n            },\n        ], this.baseStats.potency, this.getTempStat(\"potency\"));\n    }\n    set potency(val) {\n        this.baseStats.potency = val;\n    }\n    /* The likelyhood (decimal) of counter attacking */\n    get counterChance() {\n        if (this._character.statusEffect.hasDebuff(\"Stun\")) {\n            return 0;\n        }\n        const chance = this.getModifiedStats([], 0, this.getTempStat(\"counterChance\"));\n        return chance;\n    }\n    /* The amount of damage dealt when counter attacking (decimal) */\n    get counterDamage() {\n        const damageAmount = this.getModifiedStats([], 1, this.getTempStat(\"counterDamage\"));\n        return damageAmount;\n    }\n    /** The modified physical stats of a character */\n    get physical() {\n        const self = this;\n        return {\n            /** Physical Offense */\n            get offense() {\n                let stat = self.baseStats.physical.offense;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 26 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"agi\") {\n                        stat += 26 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 27 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 12 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Offense Down\"),\n                        value: -0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Offense Up\"),\n                        value: 0.5,\n                    },\n                ], stat, self.getTempStat(\"physicalOffense\"), true);\n            },\n            set offense(val) {\n                self.baseStats.physical.offense = val;\n            },\n            /** Physical Crit Chance (decimal) */\n            get critChance() {\n                let stat = self.baseStats.physical.critChance;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0045 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Critical Chance Down\"),\n                        value: -0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Critical Chance Up\"),\n                        value: 0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Call to Action\"),\n                        value: 0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasStatusEffect(\"Guard\"),\n                        value: 0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Advantage\"),\n                        value: 2,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Translation\", undefined, 2),\n                        value: 0.15,\n                    },\n                ], stat, self.getTempStat(\"physicalCritChance\"));\n            },\n            set critChance(val) {\n                self.baseStats.physical.critChance = val;\n            },\n            /** Physical Armor (flat number) */\n            get armor() {\n                let stat = self.baseStats.physical.armor;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"str\") {\n                        stat *= 0.1 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"str\") {\n                        stat *= 0.06 * self.mastery;\n                    }\n                }\n                const hasDefDown = self._character.statusEffect.hasDebuff(\"Defense Down\");\n                const hasBreach = self._character.statusEffect.hasDebuff(\"Breach\");\n                const armorShredCount = self._character.statusEffect.statusEffects.filter((s) => s.name === \"Armor Shred\").length;\n                const armorShredValue = self._character.hasTags(\"Galactic Legend\", self._character.id)\n                    ? -0.25\n                    : -0.5;\n                return self.getModifiedStats([\n                    {\n                        hasEffect: hasDefDown || hasBreach,\n                        value: hasDefDown ? -0.5 : -0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Defense Up\"),\n                        value: 0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasStatusEffect(\"Armor Shred\"),\n                        value: armorShredCount * armorShredValue,\n                    },\n                ], stat, self.getTempStat(\"physicalArmor\"), true);\n            },\n            set armor(val) {\n                self.baseStats.physical.armor = val;\n            },\n            /** Physical Armor Penetration */\n            get armorPen() {\n                let stat = self.baseStats.physical.armorPen;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 2 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 2 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Defense Penetration Down\"),\n                        value: -150,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Defense Penetration Up\"),\n                        value: 150,\n                    },\n                ], stat, self.getTempStat(\"physicalArmorPen\"));\n            },\n            set armorPen(val) {\n                self.baseStats.physical.armorPen = val;\n            },\n            /** Physical Accuracy (decimal) */\n            get accuracy() {\n                let stat = self.baseStats.physical.accuracy;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Accuracy Down\"),\n                        value: -0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Accuracy Up\"),\n                        value: 0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Blind\"),\n                        value: -Infinity,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Call to Action\"),\n                        value: 0.5,\n                    },\n                ], stat, self.getTempStat(\"physicalAccuracy\"));\n            },\n            set accuracy(val) {\n                self.baseStats.physical.accuracy = val;\n            },\n            /** Physical Dodge Chance (decimal) */\n            get dodge() {\n                let stat = self.baseStats.physical.dodge;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Evasion Down\"),\n                        value: -0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Evasion Up\"),\n                        value: 0.15,\n                    },\n                ], stat, self.getTempStat(\"physicalDodge\"));\n            },\n            set dodge(val) {\n                self.baseStats.physical.dodge = val;\n            },\n            /** Physical Critical Avoice (decimal) */\n            get critAvoid() {\n                let stat = self.baseStats.physical.critAvoid;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.0045 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Vulnerable\"),\n                        value: -Infinity,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Critical Hit Immunity\") ||\n                            self._character.statusEffect.hasStatusEffect(\"Guard\"),\n                        value: Infinity,\n                    },\n                ], stat, self.getTempStat(\"physicalCritAvoid\"));\n            },\n            set critAvoid(val) {\n                self.baseStats.physical.critAvoid = val;\n            },\n        };\n    }\n    /** The modified special stats of a character */\n    get special() {\n        const self = this;\n        return {\n            get offense() {\n                let stat = self.baseStats.special.offense;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 26 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"agi\") {\n                        stat += 26 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 27 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 12 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Offense Down\"),\n                        value: -0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Offense Up\"),\n                        value: 0.5,\n                    },\n                ], stat, self.getTempStat(\"specialOffense\"), true);\n            },\n            set offense(val) {\n                self.baseStats.special.offense = val;\n            },\n            get critChance() {\n                let stat = self.baseStats.special.critChance;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0045 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Critical Chance Down\"),\n                        value: -0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Critical Chance Up\"),\n                        value: 0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Call to Action\"),\n                        value: 0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasStatusEffect(\"Guard\"),\n                        value: 0.25,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Advantage\"),\n                        value: 2,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Translation\", undefined, 2),\n                        value: 0.15,\n                    },\n                ], stat, self.getTempStat(\"specialCritChance\"));\n            },\n            set critChance(val) {\n                self.baseStats.special.critChance = val;\n            },\n            get armor() {\n                let stat = self.baseStats.special.armor;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat *= 0.1 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat *= 0.1 * self.mastery;\n                    }\n                }\n                const armorShredCount = self._character.statusEffect.statusEffects.filter((s) => s.name === \"Armor Shred\").length;\n                const armorShredValue = self._character.hasTags(\"Galactic Legend\", self._character.id)\n                    ? -0.25\n                    : -0.5;\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Defense Down\"),\n                        value: -0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Defense Up\"),\n                        value: 0.5,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasStatusEffect(\"Armor Shred\"),\n                        value: armorShredCount * armorShredValue,\n                    },\n                ], stat, self.getTempStat(\"specialArmor\"), true);\n            },\n            set armor(val) {\n                self.baseStats.special.armor = val;\n            },\n            get armorPen() {\n                let stat = self.baseStats.special.armorPen;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 2 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 2 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Defense Penetration Down\"),\n                        value: -150,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Defense Penetration Up\"),\n                        value: 150,\n                    },\n                ], stat, self.getTempStat(\"specialArmorPen\"));\n            },\n            set armorPen(val) {\n                self.baseStats.special.armorPen = val;\n            },\n            get accuracy() {\n                let stat = self.baseStats.special.accuracy;\n                if (self._role === \"Attacker\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"str\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                    else if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Accuracy Down\"),\n                        value: -0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Accuracy Up\"),\n                        value: 0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Call to Action\"),\n                        value: 0.5,\n                    },\n                ], stat, self.getTempStat(\"specialAccuracy\"));\n            },\n            set accuracy(val) {\n                self.baseStats.special.accuracy = val;\n            },\n            get dodge() {\n                let stat = self.baseStats.special.dodge;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"agi\") {\n                        stat += 0.0035 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Evasion Down\"),\n                        value: -0.15,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Evasion Up\"),\n                        value: 0.15,\n                    },\n                ], stat, self.getTempStat(\"specialDodge\"));\n            },\n            set dodge(val) {\n                self.baseStats.special.dodge = val;\n            },\n            get critAvoid() {\n                let stat = self.baseStats.special.critAvoid;\n                if (self._role === \"Tank\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.0045 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Healer\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                else if (self._role === \"Support\") {\n                    if (self._primaryStat === \"tac\") {\n                        stat += 0.003 * self.mastery;\n                    }\n                }\n                return self.getModifiedStats([\n                    {\n                        hasEffect: self._character.statusEffect.hasDebuff(\"Vulnerable\"),\n                        value: -Infinity,\n                    },\n                    {\n                        hasEffect: self._character.statusEffect.hasBuff(\"Critical Hit Immunity\") ||\n                            self._character.statusEffect.hasStatusEffect(\"Guard\"),\n                        value: Infinity,\n                    },\n                ], stat, self.getTempStat(\"specialCritAvoid\"));\n            },\n            set critAvoid(val) {\n                self.baseStats.special.critAvoid = val;\n            },\n        };\n    }\n    /** The current Health Steal (decimal) */\n    get healthSteal() {\n        let stat = this.baseStats.healthSteal;\n        if (this._role === \"Tank\") {\n            if (this._primaryStat === \"str\") {\n                stat += 0.0015 * this.mastery;\n            }\n        }\n        else if (this._role === \"Healer\") {\n            if (this._primaryStat === \"str\") {\n                stat *= 0.0015 * this.mastery;\n            }\n        }\n        return this.getModifiedStats([\n            {\n                hasEffect: this._character.statusEffect.hasDebuff(\"Health Steal Down\"),\n                value: -0.5,\n            },\n            {\n                hasEffect: this._character.statusEffect.hasBuff(\"Health Steal Up\"),\n                value: 0.5,\n            },\n        ], stat, this.getTempStat(\"healthSteal\"));\n    }\n    /**\n     * Gets an array of stats that are currently being changed through various effects\n     * @param statName\n     * @returns An array of stats that should be changed\n     */\n    getTempStat(statName) {\n        return this.tempStats.reduce((list, stat) => {\n            if (stat.statToModify === statName &&\n                this._character.checkCondition(stat.condition)) {\n                list.push(stat);\n            }\n            return list;\n        }, []);\n    }\n    /**\n     * Gets the modified stats based on if an effect is present (such as Offense Up)\n     * @param statusEffectConfig - An object containing if an effect is present and by how much the stat should be adjusted\n     * @param baseStat - The base value of the stat to be used\n     * @param tempStats - An array of any temporary stats that may exist\n     * @param isMultiplicative - Determines if the stat should be multiplied (true) or added together (false)\n     * @returns The number of the new value for the stat\n     */\n    getModifiedStats(statusEffectConfig, baseStat, tempStats, isMultiplicative = false) {\n        let newStat = baseStat;\n        tempStats\n            .sort((a, b) => {\n            if (a.modifiedType === \"multiplicative\" &&\n                b.modifiedType === \"multiplicative\") {\n                return 0;\n            }\n            else if (a.modifiedType === \"multiplicative\") {\n                return 1;\n            }\n            else if (b.modifiedType === \"multiplicative\") {\n                return -1;\n            }\n            return 0;\n        })\n            .forEach((stat) => {\n            if (stat?.modifiedType === \"multiplicative\") {\n                newStat += baseStat * stat.amount;\n            }\n            else {\n                newStat += stat.amount;\n            }\n        });\n        let amountIncrease = 0;\n        statusEffectConfig.forEach((effect) => {\n            if (effect.hasEffect) {\n                amountIncrease += effect.value;\n            }\n        });\n        if (isMultiplicative) {\n            return newStat * (1 + amountIncrease);\n        }\n        else {\n            return newStat + amountIncrease;\n        }\n    }\n    /** Gets the current combat stats of the character after all effects have been applied\n     * @param damageType - The type of damage being dealt (physical, special, or true)\n     * @param stats - An array of stats to modify the starting stat value\n     * @returns - A map of the stats and their current values\n     */\n    getCombatStats(damageType, stats) {\n        const baseStat = damageType === \"physical\" ? this.physical : this.special;\n        const mapping = {\n            offense: baseStat.offense,\n            critChance: baseStat.critChance,\n            armorPen: baseStat.armorPen,\n            armor: baseStat.armor,\n            dodge: baseStat.dodge,\n            accuracy: baseStat.accuracy,\n            critAvoid: baseStat.critAvoid,\n            maxHealth: this.maxHealth,\n            health: this.health,\n            maxProtection: this.maxProtection,\n            protection: this.protection,\n        };\n        if (damageType === \"physical\" || damageType === \"special\") {\n            mapping.offense = modifyStat(baseStat.offense, (damageType + \"Offense\"), stats);\n            mapping.critChance = modifyStat(baseStat.critChance, (damageType + \"CritChance\"), stats);\n            mapping.armorPen = modifyStat(baseStat.armorPen, (damageType + \"ArmorPen\"), stats);\n            mapping.armor = modifyStat(baseStat.armor, (damageType + \"Armor\"), stats);\n            mapping.dodge = modifyStat(baseStat.dodge, (damageType + \"Dodge\"), stats);\n            mapping.accuracy = modifyStat(baseStat.accuracy, (damageType + \"Accuracy\"), stats);\n            mapping.critAvoid = modifyStat(baseStat.critAvoid, (damageType + \"CritAvoid\"), stats);\n        }\n        return mapping;\n    }\n    addTempStats(statsList, srcAbility) {\n        this.tempStats.push(...statsList);\n        let statLabels = [];\n        statsList.forEach((stat) => {\n            let amountLabel = stat.amount.toString();\n            if (stat.modifiedType === \"multiplicative\" || stat.amount <= 1) {\n                amountLabel = `${stat.amount * 100}%`;\n            }\n            const conditionLabel = stat.condition ? \" (if a condition is met)\" : \"\";\n            statLabels.push(`${amountLabel} ${stat.statToModify}${conditionLabel}`);\n        });\n        if (statLabels.length > 0) {\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                customMessage: `gained ${statLabels.join(\", \")}`,\n                ability: { source: srcAbility?.sanitize() },\n            });\n        }\n    }\n    removeTempStats(characterId, effectId) {\n        this.tempStats = this.tempStats.filter((stat) => {\n            if (stat.characterSourceId === characterId ||\n                (stat.id === effectId && effectId !== undefined)) {\n                let amountLabel = stat.amount.toString();\n                if (stat.modifiedType === \"multiplicative\") {\n                    amountLabel = `${stat.amount * 100}%`;\n                }\n                this._character.gameEngine.addLogs({\n                    characterLogData: this._character.getLogs(),\n                    customMessage: `removed ${amountLabel} (${stat.modifiedType}) ${stat.statToModify}`,\n                });\n                return false;\n            }\n            return true;\n        });\n    }\n    /** Removes any stats that shouldnt be present any more after the turn has ended */\n    endOfTurn() {\n        this.tempStats = this.tempStats.reduce((list, stat) => {\n            if (stat.expires?.frequency === \"turn\") {\n                stat.expires.count--;\n                if (stat.expires.count > 0) {\n                    list.push(stat);\n                }\n            }\n            else if (!stat.expires) {\n                list.push(stat);\n            }\n            return list;\n        }, []);\n    }\n    /** Resets all temporary stats and effects  */\n    reset() {\n        this.tempStats = [];\n    }\n}\n/** Modifies the stat based on a flat amount of multimplicative value\n * @param startingStatValue - The starting stat value\n * @param statType - The type of stat used to modify the starting stat (e.g. offense, health, etc.)\n * @param stats - An array of stats to modify the starting stat value\n * @returns The modified value of the stat\n */\nfunction modifyStat(startingStatValue, statType, stats) {\n    let modifiedStat = startingStatValue;\n    if (stats) {\n        stats.forEach((s) => {\n            if (statType === s?.statToModify) {\n                if (s.modifiedType === \"multiplicative\") {\n                    modifiedStat *= s.amount;\n                }\n                else if (s.modifiedType === \"additive\") {\n                    modifiedStat += s.amount;\n                }\n            }\n        });\n    }\n    return modifiedStat;\n}\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characters/stats.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characters/statusEffects.ts":
/*!**********************************************************!*\
  !*** ./src/types/gameEngine/characters/statusEffects.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StatusEffect: () => (/* binding */ StatusEffect)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _abilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abilities */ \"./src/types/gameEngine/characters/abilities.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/types/gameEngine/characters/utils.ts\");\n\n\n\n\n/** A container class used to hold all of a character's status effects (buffs, debuffs, etc.) any utility functions */\nclass StatusEffect {\n    _buffs = [];\n    _debuffs = [];\n    _statusEffects = [];\n    _character;\n    _immunity = [];\n    constructor(parentCharacter) {\n        this._character = parentCharacter;\n    }\n    /** An initializer function that resets various properties */\n    initialize() {\n        this._debuffs = [];\n        this._buffs = [];\n        this._statusEffects = [];\n    }\n    /** Removes any effects that shouldnt be present any more after the turn has ended */\n    endOfTurn() {\n        const { debuffsRemoved } = this.debuffs.reduce((acc, debuff) => {\n            if (debuff.isNew) {\n                debuff.isNew = false;\n            }\n            else {\n                debuff.duration--;\n            }\n            if (debuff.duration <= 0 && debuff.name) {\n                acc.debuffsRemoved.push(debuff.name);\n            }\n            return acc;\n        }, { debuffsRemoved: [] });\n        const { buffsRemoved } = this.buffs.reduce((acc, buff) => {\n            if (buff.isNew) {\n                buff.isNew = false;\n            }\n            else {\n                buff.duration--;\n            }\n            if (buff.duration <= 0 && buff.name) {\n                acc.buffsRemoved.push(buff.name);\n            }\n            return acc;\n        }, { buffsRemoved: [] });\n        const { statusEffectsRemoved } = this._statusEffects.reduce((acc, statusEffect) => {\n            if (statusEffect.isNew) {\n                statusEffect.isNew = false;\n            }\n            else {\n                statusEffect.duration--;\n            }\n            // if (statusEffect.duration <= 0) {\n            //   acc.statusEffectsRemoved.push(statusEffect);\n            // }\n            return acc;\n        }, { statusEffectsRemoved: [] });\n        debuffsRemoved.forEach((debuff) => {\n            this.removeDebuff(debuff);\n        });\n        buffsRemoved.forEach((buff) => {\n            this.removeBuff(buff);\n        });\n        statusEffectsRemoved.forEach((effect) => {\n            this.removeStatusEffect(effect);\n        });\n        // buffsRemoved.forEach((buff) => {\n        //   logs.push(...this.statusEffect.removeBuff(buff));\n        // });\n    }\n    /* A list of debuffs currently on the character */\n    get debuffs() {\n        return this._debuffs;\n    }\n    /* A list of buffs currently on the character */\n    get buffs() {\n        return this._buffs;\n    }\n    /* A list of status effects currently on the character */\n    get statusEffects() {\n        return this._statusEffects;\n    }\n    /** Checks to see if the character has any of the listed debuffs\n     * @param debuffs - The list of debuffs to check. If an array, checks that ALL of the ones listed are present\n     * @param duration - The duration to check if there are any remaining turns left on the debuff\n     * @param stacks - The number to check if there are at least this many stacks of the given buffs\n     * @returns true if the character has the debuffs\n     */\n    hasDebuff(debuffs, duration, stacks) {\n        if (Array.isArray(debuffs)) {\n            return debuffs.every((x) => this.hasDebuff(x, duration));\n        }\n        else {\n            let stacksCount = 0;\n            return this.debuffs.some((d) => {\n                if (typeof debuffs === \"string\") {\n                    if (d.name === debuffs) {\n                        if (duration) {\n                            return duration <= d.duration;\n                        }\n                        else if (stacks) {\n                            stacksCount++;\n                            return stacks <= stacksCount;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                else {\n                    return d.id === debuffs?.id;\n                }\n            });\n        }\n    }\n    /** Checks to see if the character has any of the listed buffs\n     * @param buffs - The list of buffs to check. If an array, checks that ALL of the ones listed are present\n     * @param duration - The duration to check if there are any remaining turns left on the buff\n     * @param stacks - The number to check if there are at least this many stacks of the given buffs\n     * @param isNew - Checks if the buff is new this turn or not\n     * @returns true if the character has the buffs\n     */\n    hasBuff(buffs, duration, stacks, isNew) {\n        if (Array.isArray(buffs)) {\n            return buffs.every((x) => this.hasBuff(x, duration, stacks, isNew));\n        }\n        else {\n            let stacksCount = 0;\n            return this.buffs.some((b) => {\n                if (typeof buffs === \"string\") {\n                    if (b.name === buffs) {\n                        if (duration) {\n                            return duration <= b.duration;\n                        }\n                        else if (stacks) {\n                            stacksCount++;\n                            return stacks <= stacksCount;\n                        }\n                        else if (isNew !== undefined) {\n                            return b.isNew === isNew;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                else {\n                    return b.id === buffs?.id;\n                }\n            });\n        }\n    }\n    /** Checks to see if the character has any of the listed status effects\n     * @param statusEffects - The list of status effects to check. If an array, checks that ALL of the ones listed are present\n     * @param duration - The duration to check if there are any remaining turns left on the debuff\n     */\n    hasStatusEffect(statusEffects, duration) {\n        if (Array.isArray(statusEffects)) {\n            return statusEffects.every((x) => this.hasStatusEffect(x, duration));\n        }\n        else {\n            return this._statusEffects.some((d) => {\n                if (typeof statusEffects === \"string\") {\n                    if (d.name === statusEffects) {\n                        if (duration) {\n                            return duration <= d.duration;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                else {\n                    return d.id === statusEffects.id;\n                }\n            });\n        }\n    }\n    /** Changes the duration of all stacks of a particular status effect\n     * @param effect - The name of the effect that should be changed\n     * @param duration - The duration to change the effect to\n     * @param type - The type of effect (buff, debuff, or status effect)\n     * @param srcAbility - The source ability that is causing the effect to be reset\n     */\n    resetDuration(effect, duration, type, srcAbility) {\n        let shouldLog = [];\n        [...this._buffs, ...this._debuffs, ...this._statusEffects].forEach((statusEffect) => {\n            if (statusEffect.name === effect) {\n                statusEffect.duration = duration;\n                shouldLog.push({\n                    name: statusEffect.name ?? \"\",\n                    duration: statusEffect.duration,\n                    sourceAbility: statusEffect.sourceAbility?.sanitize(),\n                });\n            }\n        });\n        if (shouldLog.length > 0) {\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                statusEffects: {\n                    type,\n                    list: shouldLog,\n                    reset: duration,\n                },\n                ability: { source: srcAbility?.sanitize() },\n            });\n        }\n    }\n    /** Checks to see if the character is immune to the effect\n     * @param statusEffect - The status effect to check\n     * @returns true if the character is currently immune to the effect\n     */\n    isImmune(statusEffect) {\n        if (typeof statusEffect === \"string\") {\n            return this.immunity[statusEffect]?.value ?? false;\n        }\n        else {\n            return this.immunity[statusEffect?.name ?? \"\"]?.value ?? false;\n        }\n    }\n    /** Adds a buff to the character\n     * @param buff - The buff being added\n     * @param scalar - The amount the duration should be scaled by (usually 1)\n     * @param sourceAbility - The source ability that is adding the buff\n     * @param maxStacks - The maximum amount of stacks that can be applied for this debuff\n     */\n    addBuff(buff, scalar, sourceAbility, maxStacks) {\n        const hasBuffImmunity = this.hasDebuff(\"Buff Immunity\");\n        const hasConfuse = this.hasDebuff(\"Confuse\");\n        if (Array.isArray(buff)) {\n            buff.forEach((someBuff) => {\n                this.addBuff(someBuff, scalar, sourceAbility);\n            });\n        }\n        else if ((hasBuffImmunity || hasConfuse) && !buff.cantPrevent) {\n            let preventedSource = \"\";\n            if (hasBuffImmunity) {\n                preventedSource = \"Buff Immunity\";\n            }\n            else if (hasConfuse) {\n                preventedSource = \"Confused\";\n            }\n            this._character.gameEngine.addLogs({\n                characterLogData: this._character.getLogs(),\n                statusEffects: {\n                    prevented: preventedSource,\n                    list: [\n                        {\n                            name: buff.name ?? \"\",\n                            duration: buff.duration,\n                            sourceAbility: buff.sourceAbility?.sanitize(),\n                        },\n                    ],\n                    type: \"buff\",\n                },\n            });\n        }\n        else {\n            const logAndDispatch = () => {\n                this._character.gameEngine.addLogs({\n                    characterLogData: this._character.getLogs(),\n                    ability: { source: sourceAbility?.sanitize() },\n                    statusEffects: {\n                        type: \"buff\",\n                        list: [\n                            {\n                                name: buff.name ?? \"\",\n                                duration: buff.duration,\n                                sourceAbility: buff.sourceAbility?.sanitize(),\n                            },\n                        ],\n                        duration: buff.duration,\n                    },\n                });\n                this._character.dispatchEvent(\"buffed\", { buff });\n            };\n            if (this.isImmune(buff)) {\n                this._character.gameEngine.addLogs({\n                    characterLogData: this._character.getLogs(),\n                    statusEffects: {\n                        type: \"buff\",\n                        immune: true,\n                        list: [\n                            {\n                                name: buff.name ?? \"\",\n                                duration: buff.duration,\n                                sourceAbility: buff.sourceAbility?.sanitize(),\n                            },\n                        ],\n                    },\n                });\n            }\n            else if (this.hasBuff(buff.name, undefined, maxStacks)) {\n                if (buff.name === \"Protection Up\") {\n                    if (buff.isStackable) {\n                        this.buffs.push(buff);\n                        logAndDispatch();\n                        return;\n                    }\n                    else {\n                        const match = this.buffs.find((b) => b.sourceAbility === buff.sourceAbility);\n                        if (match) {\n                            match.value = Math.max(buff?.value ?? 0, match?.value ?? 0);\n                            match.duration = Math.max(buff?.duration ?? 0, match?.duration ?? 0);\n                            logAndDispatch();\n                            return;\n                        }\n                    }\n                }\n                this.buffs.forEach((b) => {\n                    if (b.name === buff.name) {\n                        this.resetDuration(buff.name, Math.max(b.duration, buff.duration), \"buff\", sourceAbility ?? undefined);\n                        this._character.dispatchEvent(\"buffed\", { buff });\n                    }\n                });\n            }\n            this._buffs.push({\n                ...lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(buff),\n                isNew: true,\n            });\n            logAndDispatch();\n        }\n    }\n    /** Removes a buff from the character\n     * @param buff - The buff being removed\n     * @param character - The character that is causing the removal\n     * @param sourceAbility - The ability that is causing the removal\n     */\n    removeBuff(buff, character, sourceAbility) {\n        const listOfRemovedBuffs = [];\n        if (Array.isArray(buff)) {\n            buff.forEach((b) => this.removeBuff(b, character, sourceAbility));\n        }\n        else {\n            let buffToRemove = null;\n            if (typeof buff === \"string\") {\n                buffToRemove = {\n                    name: buff,\n                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(),\n                    duration: 1,\n                    sourceAbility: sourceAbility ?? null,\n                };\n            }\n            else {\n                buffToRemove = buff;\n            }\n            this._buffs = this._buffs.filter((b) => {\n                if (b.name === buffToRemove?.name ||\n                    buffToRemove?.name === \"all\" ||\n                    b.id === buffToRemove?.id) {\n                    if (b.cantDispel && !this._character.isSelf(character)) {\n                        return true;\n                    }\n                    listOfRemovedBuffs.push(b);\n                    return false;\n                }\n                return true;\n            });\n            if (listOfRemovedBuffs.length > 0) {\n                if (character && !this._character.isSelf(character)) {\n                    //opponent removed them\n                    this._character.gameEngine.addLogs({\n                        characterLogData: character.getLogs(),\n                        targetLogData: this._character.getLogs(),\n                        ability: { source: sourceAbility?.sanitize() },\n                        statusEffects: {\n                            type: \"buff\",\n                            list: listOfRemovedBuffs.map((b) => {\n                                return {\n                                    name: b.name ?? \"\",\n                                    duration: b.duration,\n                                    sourceAbility: b.sourceAbility?.sanitize(),\n                                };\n                            }),\n                            removed: true,\n                        },\n                    });\n                }\n                else {\n                    //was naturally removed\n                    this._character.gameEngine.addLogs({\n                        characterLogData: this._character.getLogs(),\n                        ability: { source: sourceAbility?.sanitize() },\n                        statusEffects: {\n                            type: \"buff\",\n                            list: listOfRemovedBuffs.map((b) => {\n                                return {\n                                    name: b.name ?? \"\",\n                                    duration: b.duration,\n                                    sourceAbility: b.sourceAbility?.sanitize(),\n                                };\n                            }),\n                            removed: true,\n                        },\n                    }, character == undefined);\n                }\n                this._character.dispatchEvent(\"dispel\", {\n                    effects: listOfRemovedBuffs,\n                });\n            }\n        }\n    }\n    /** Inflicts debuffs on the target character\n     * @param debuffs - A list of debuffs to be added\n     * @param targetCharacter - The character receiving the debuffs\n     * @param scalar - The amount the duration should be scaled by (usually 1)\n     * @param sourceAbility - The source ability that is adding the debuff\n     * @param maxStacks - The maximum amount of stacks that can be applied for this debuff\n     */\n    inflictDebuff(debuffs, targetCharacter, scalar = 1, sourceAbility, maxStacks) {\n        if (targetCharacter.isDead) {\n            return;\n        }\n        debuffs.forEach((debuff) => {\n            if (targetCharacter.statusEffect.isImmune(debuff)) {\n                this._character.gameEngine.addLogs({\n                    characterLogData: targetCharacter.getLogs(),\n                    statusEffects: {\n                        type: \"debuff\",\n                        immune: true,\n                        list: [\n                            {\n                                name: debuff.name ?? \"\",\n                                duration: debuff.duration,\n                                sourceAbility: debuff.sourceAbility?.sanitize(),\n                            },\n                        ],\n                    },\n                });\n            }\n            else if (!targetCharacter.statusEffect.hasDebuff(debuff.name, debuff.duration, maxStacks) ||\n                debuff.isStackable) {\n                const resistedChance = Math.max(targetCharacter.stats.tenacity - this._character.stats.potency, 0.15);\n                if (!(0,_utils__WEBPACK_IMPORTED_MODULE_2__.chanceOfEvent)(resistedChance) ||\n                    debuff.cantResist ||\n                    debuff.name === \"Tenacity Down\" ||\n                    this._character.isSelf(targetCharacter)) {\n                    if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.chanceOfEvent)(debuff.chance ?? 0)) {\n                        return;\n                    }\n                    const newDuration = debuff.duration * scalar;\n                    if (!targetCharacter.statusEffect.hasDebuff(debuff?.name, newDuration) ||\n                        debuff.isStackable) {\n                        const match = targetCharacter.statusEffect.debuffs.find((x) => x.name === debuff.name);\n                        if (debuff.isStackable || !match) {\n                            targetCharacter.statusEffect.debuffs.push({\n                                ...lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(debuff),\n                                duration: newDuration,\n                                isNew: true,\n                            });\n                        }\n                        else {\n                            match.duration = newDuration;\n                            match.isNew = true;\n                        }\n                        this._character.gameEngine.addLogs({\n                            characterLogData: targetCharacter.getLogs(),\n                            statusEffects: {\n                                list: [\n                                    {\n                                        name: debuff.name ?? \"\",\n                                        duration: debuff.duration,\n                                        sourceAbility: debuff.sourceAbility?.sanitize(),\n                                    },\n                                ],\n                                duration: newDuration,\n                                type: \"debuff\",\n                            },\n                            ability: {\n                                source: sourceAbility?.sanitize(),\n                            },\n                        });\n                        this._character.dispatchEvent(\"inflicted\", { effect: debuff.name });\n                    }\n                }\n                else {\n                    this._character.gameEngine.addLogs({\n                        characterLogData: targetCharacter.getLogs(),\n                        statusEffects: {\n                            resisted: true,\n                            list: [\n                                {\n                                    name: debuff.name ?? \"\",\n                                    duration: debuff.duration,\n                                    sourceAbility: debuff.sourceAbility?.sanitize(),\n                                },\n                            ],\n                            type: \"debuff\",\n                        },\n                    });\n                    targetCharacter.dispatchEvent(\"resisted\", { effect: debuff.name });\n                }\n            }\n        });\n    }\n    /** Removes a debuff from the character\n     * @param debuff - The debuff being removed\n     * @param opponent - The character that is causing the removal\n     * @param sourceAbility - The ability that is causing the removal\n     */\n    removeDebuff(debuff, opponent, sourceAbility) {\n        const listOfRemovedDebuffs = [];\n        if (Array.isArray(debuff)) {\n            debuff.forEach((d) => this.removeDebuff(d, opponent, sourceAbility));\n        }\n        else {\n            let debuffData = null;\n            if (typeof debuff === \"string\") {\n                debuffData = {\n                    name: debuff,\n                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(),\n                    duration: 1,\n                    sourceAbility: sourceAbility ?? null,\n                };\n            }\n            else {\n                debuffData = debuff;\n            }\n            this._debuffs = lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(this._debuffs).filter((debuff) => {\n                if (debuff.name === debuffData?.name ||\n                    debuffData?.name === \"all\" ||\n                    debuff.id === debuffData?.id) {\n                    listOfRemovedDebuffs.push(debuff);\n                    return false;\n                }\n                return true;\n            });\n            if (listOfRemovedDebuffs.length > 0) {\n                if (opponent && !this._character.isSelf(opponent)) {\n                    this._character.gameEngine.addLogs({\n                        characterLogData: opponent.getLogs(),\n                        targetLogData: this._character.getLogs(),\n                        ability: { source: sourceAbility?.sanitize() },\n                        statusEffects: {\n                            list: listOfRemovedDebuffs.map((debuff) => {\n                                return {\n                                    name: debuff.name ?? \"\",\n                                    duration: debuff.duration,\n                                    sourceAbility: debuff.sourceAbility?.sanitize(),\n                                };\n                            }),\n                            removed: true,\n                            type: \"debuff\",\n                        },\n                    }, false);\n                }\n                else {\n                    this._character.gameEngine.addLogs({\n                        characterLogData: this._character.getLogs(),\n                        ability: { source: sourceAbility?.sanitize() },\n                        statusEffects: {\n                            list: listOfRemovedDebuffs.map((debuff) => {\n                                return {\n                                    name: debuff.name ?? \"\",\n                                    duration: debuff.duration,\n                                    sourceAbility: debuff.sourceAbility?.sanitize(),\n                                };\n                            }),\n                            removed: true,\n                            type: \"debuff\",\n                        },\n                    }, opponent === undefined);\n                }\n            }\n        }\n    }\n    /** Adds a status effect to the character\n     * @param effect - The status effect being added\n     * @param srcAbility - The source ability that is adding the buff\n     */\n    addStatusEffect(effect, srcAbility) {\n        if (Array.isArray(effect)) {\n            effect.forEach((e) => this.addStatusEffect(e, srcAbility));\n        }\n        else {\n            if ((!this.hasStatusEffect(effect, effect.duration) ||\n                effect.isStackable) &&\n                !this.isImmune(effect)) {\n                const match = this._statusEffects.find((x) => x.name === effect.name);\n                if (effect.isStackable || !match) {\n                    this._statusEffects.push({\n                        ...lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(effect),\n                        isNew: true,\n                    });\n                }\n                else {\n                    match.duration = effect.duration;\n                    match.isNew = true;\n                }\n                this._character.dispatchEvent(\"gainStatusEffect\", {\n                    statusEffect: effect,\n                });\n                this._character.gameEngine.addLogs({\n                    characterLogData: this._character.getLogs(),\n                    statusEffects: {\n                        list: [\n                            {\n                                name: effect.name ?? \"\",\n                                duration: effect.duration,\n                                sourceAbility: effect.sourceAbility?.sanitize(),\n                            },\n                        ],\n                        type: \"statusEffect\",\n                        duration: effect.duration,\n                    },\n                    ability: {\n                        source: srcAbility?.sanitize(),\n                    },\n                });\n            }\n        }\n    }\n    /** Removes a status effect from the character\n     * @param statusEffect - The status effect being removed\n     * @param srcAbility - The ability that is causing the removal\n     * @param srcCharacter - The character that is causing the removal\n     */\n    removeStatusEffect(statusEffect, srcAbility, srcCharacter) {\n        if (Array.isArray(statusEffect)) {\n            statusEffect.forEach((e) => this.removeStatusEffect(e, srcAbility));\n        }\n        else {\n            const listOfRemovedStatusEffects = [];\n            let statusEffectData = null;\n            if (typeof statusEffect === \"string\") {\n                statusEffectData = {\n                    name: statusEffect,\n                    id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(),\n                    duration: 1,\n                    sourceAbility: srcAbility ?? null,\n                };\n            }\n            else {\n                statusEffectData = statusEffect;\n            }\n            this._statusEffects = lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(this._statusEffects).filter((statusEffect) => {\n                if (statusEffect.name === statusEffectData?.name ||\n                    statusEffectData?.name === \"all\" ||\n                    statusEffect.id === statusEffectData?.id) {\n                    listOfRemovedStatusEffects.push(statusEffect);\n                    return false;\n                }\n                return true;\n            });\n            if (listOfRemovedStatusEffects.length > 0) {\n                this._character.gameEngine.addLogs({\n                    characterLogData: srcCharacter?.getLogs(),\n                    targetLogData: this._character.getLogs(),\n                    ability: { source: srcAbility?.sanitize() },\n                    statusEffects: {\n                        list: listOfRemovedStatusEffects.map((effect) => {\n                            return {\n                                name: effect.name ?? \"\",\n                                duration: effect.duration,\n                                sourceAbility: effect.sourceAbility?.sanitize(),\n                            };\n                        }),\n                        removed: true,\n                        type: \"statusEffect\",\n                    },\n                });\n            }\n        }\n    }\n    /** A mapping of status effects that the character cannot gain */\n    get immunity() {\n        return this._immunity.reduce((map, el) => {\n            if (el.effect in map) {\n                if (this._character.checkCondition(el.condition)) {\n                    map[el.effect] = { value: true, sourceAbility: el.sourceAbility };\n                }\n            }\n            return map;\n        }, {\n            Daze: {\n                value: this.hasStatusEffect(\"Guard\"),\n                sourceAbility: new _abilities__WEBPACK_IMPORTED_MODULE_1__.Ability(\"Guard\", \"Guard\", \"Can't be Critically Hit, immune to Daze and Stun, +25% Critical Chance\", this._character),\n            },\n            Stun: {\n                value: this.hasStatusEffect(\"Guard\"),\n                sourceAbility: new _abilities__WEBPACK_IMPORTED_MODULE_1__.Ability(\"Guard\", \"Guard\", \"Can't be Critically Hit, immune to Daze and Stun, +25% Critical Chance\", this._character),\n            },\n            Assisting: {\n                value: this.hasDebuff(\"Daze\") || this.hasDebuff(\"Stun\"),\n                sourceAbility: new _abilities__WEBPACK_IMPORTED_MODULE_1__.Ability(this.hasDebuff(\"Daze\") ? \"Daze\" : \"Stun\", this.hasDebuff(\"Daze\") ? \"Daze\" : \"Stun\", \"Can't assist, counter attack, or gain bonus Turn Meter\", this._character),\n            },\n            CounterAttacking: {\n                value: this.hasDebuff(\"Daze\") || this.hasDebuff(\"Stun\"),\n                sourceAbility: new _abilities__WEBPACK_IMPORTED_MODULE_1__.Ability(this.hasDebuff(\"Daze\") ? \"Daze\" : \"Stun\", this.hasDebuff(\"Daze\") ? \"Daze\" : \"Stun\", \"Can't assist, counter attack, or gain bonus Turn Meter\", this._character),\n            },\n            \"Jedi Lessons\": {\n                value: this.hasBuff(\"Jedi Legacy\"),\n                sourceAbility: new _abilities__WEBPACK_IMPORTED_MODULE_1__.Ability(\"Jedi Legacy\", \"Jedi Legacy\", \"Can't gain Jedi Lessons because this unit has Jedi Legacy\", this._character),\n            },\n        });\n    }\n    sanitizeImmunity() {\n        const map = {};\n        Object.entries(this.immunity).forEach(([key, value]) => {\n            map[key] = {\n                value: value.value,\n                sourceAbility: value.sourceAbility?.sanitize(),\n            };\n        });\n        return map;\n    }\n    /**\n     * Add an effect that the character is now immune to\n     * @param sourceId - The unique key that is used to reference the immunity\n     * @param effect - The effect that the user is now immune to\n     * @param condition - A condition to check if the immune effect should be added\n     * @param sourceAbility - The ability source that is adding the immune effect\n     */\n    addImmune(sourceId, effect, condition, sourceAbility) {\n        this._immunity.push({\n            sourceId,\n            value: true,\n            effect,\n            condition,\n            sourceAbility,\n        });\n    }\n    /**\n     * Remove an existing effect that the character is now no longer immune to\n     * @param sourceId - The unique key that is used to reference the immunity\n     * @param effect - The effect that the user should no longer be immune to\n     */\n    removeImmune(sourceId, effect) {\n        const index = this._immunity.findIndex((x) => x.sourceId === sourceId && effect === x.effect);\n        if (index > -1) {\n            this._immunity.splice(index, 1);\n        }\n    }\n    /** Resets all temporary status effect lists and immunities  */\n    reset() {\n        this._buffs = [];\n        this._debuffs = [];\n        this._statusEffects = [];\n        this._immunity = [];\n    }\n}\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characters/statusEffects.ts?");

/***/ }),

/***/ "./src/types/gameEngine/characters/utils.ts":
/*!**************************************************!*\
  !*** ./src/types/gameEngine/characters/utils.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chanceOfEvent: () => (/* binding */ chanceOfEvent),\n/* harmony export */   randomNumber: () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * Checks the likelihood of something happening\n *\n * @param percentChance - The chances of something happening (can be either decimal or whole number)\n * @returns Whether the event has occurred\n */\nfunction chanceOfEvent(percentChance) {\n    if (percentChance < 1) {\n        percentChance *= 100;\n    }\n    return percentChance >= randomNumber(1, 100);\n}\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/characters/utils.ts?");

/***/ }),

/***/ "./src/types/gameEngine/gameEngine.ts":
/*!********************************************!*\
  !*** ./src/types/gameEngine/gameEngine.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: () => (/* binding */ Engine),\n/* harmony export */   Turn: () => (/* binding */ Turn)\n/* harmony export */ });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _characters_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./characters/utils */ \"./src/types/gameEngine/characters/utils.ts\");\n\n\nclass Turn {\n    logs = [];\n    endOfTurnLogs = [];\n    _turnNumber = 0;\n    _character = null;\n    _label = null;\n    characterList = [];\n    engine;\n    constructor(turnNumber, character, gameEngine, logs, endOfTurnLogs, label) {\n        this._turnNumber = turnNumber;\n        this._character = character;\n        this.logs = logs ?? [];\n        this.endOfTurnLogs = endOfTurnLogs ?? [];\n        this._label = label ?? null;\n        this.engine = gameEngine;\n        this.characterList = this.engine.allCharacters\n            .map((c) => {\n            const logs = c.getLogs();\n            return {\n                name: c.name,\n                owner: c.owner,\n                turnMeter: lodash__WEBPACK_IMPORTED_MODULE_0___default().round(logs.turnMeter, 2),\n            };\n        })\n            .sort((a, b) => {\n            return a.turnMeter > b.turnMeter ? -1 : 1;\n        });\n    }\n    get turnNumber() {\n        return this._turnNumber;\n    }\n    get character() {\n        return this._character;\n    }\n    get label() {\n        return this._label ?? `Turn ${this.turnNumber}`;\n    }\n    addLogs(logs, endOfTurn) {\n        if (endOfTurn || this.endOfTurnLogs.length > 0) {\n            this.endOfTurnLogs.push(...logs.filter((l) => !!l));\n        }\n        else {\n            this.logs.push(...logs.filter((l) => !!l));\n        }\n    }\n    sanitize() {\n        return {\n            label: this.label,\n            turnNumber: this.turnNumber,\n            logs: this.logs,\n            endOfTurnLogs: this.endOfTurnLogs,\n            characterList: this.characterList,\n        };\n    }\n}\nclass Engine {\n    _playerCharacters = [];\n    _opponentCharacters = [];\n    _simulationData = {\n        // total: 1,\n        playerWins: 0,\n        opponentWins: 0,\n        matchHistory: [],\n    };\n    turns = [];\n    constructor() { }\n    get allCharacters() {\n        return [...this._playerCharacters, ...this._opponentCharacters];\n    }\n    // public get totalSimulations() {\n    //   return this._simulationData.total;\n    // }\n    // public set totalSimulations(val: number) {\n    //   if (val <= 10) {\n    //     this._simulationData.total = val;\n    //   }\n    // }\n    get matchHistory() {\n        return this._simulationData.matchHistory;\n    }\n    get playerWins() {\n        return this._simulationData.playerWins;\n    }\n    get opponentWins() {\n        return this._simulationData.opponentWins;\n    }\n    get playerWinRate() {\n        return (lodash__WEBPACK_IMPORTED_MODULE_0___default().round(this.playerWins / (this.playerWins + this.opponentWins), 2) * 100);\n    }\n    get opponentWinRate() {\n        return (lodash__WEBPACK_IMPORTED_MODULE_0___default().round(this.opponentWins / (this.playerWins + this.opponentWins), 2) *\n            100);\n    }\n    get currentCharactersTurn() {\n        if (this.turns.length) {\n            return this.turns[this.turns.length - 1].character;\n        }\n        else {\n            return null;\n        }\n    }\n    startSimulation(playerUnits, opponentUnits, amountOfSimulations) {\n        this._simulationData.matchHistory = [];\n        this._simulationData.opponentWins = 0;\n        this._simulationData.playerWins = 0;\n        for (let i = 0; i < amountOfSimulations; i++) {\n            this.initializeMatch(playerUnits, opponentUnits);\n            let turnNumber = 0;\n            do {\n                console.time(\"turn\");\n                turnNumber++;\n                this.nextTurn(turnNumber);\n                if (this.checkMatchEnd(turnNumber, 9999)) {\n                    this._simulationData.matchHistory.push(this.turns.map((t) => t.sanitize()));\n                    break;\n                }\n                console.timeEnd(\"turn\");\n            } while (true);\n        }\n        return {\n            matchHistory: this.matchHistory,\n            playerWins: this._simulationData.playerWins,\n            opponentWins: this._simulationData.opponentWins,\n            playerWinRate: this.playerWinRate,\n        };\n    }\n    initializeMatch(playerUnits, opponentUnits) {\n        this.turns = [new Turn(0, null, this, [], [], \"Initialilze Match\")];\n        this._playerCharacters = [];\n        this._opponentCharacters = [];\n        playerUnits.forEach((unit) => {\n            if (!this._playerCharacters.some((x) => x.id === unit.id)) {\n                this._playerCharacters.push(unit);\n            }\n        });\n        opponentUnits.forEach((unit) => {\n            if (!this._opponentCharacters.some((x) => x.id === unit.id)) {\n                this._opponentCharacters.push(unit);\n            }\n        });\n        this._playerCharacters.forEach((x) => x.reset(this._playerCharacters, this._opponentCharacters));\n        this._opponentCharacters.forEach((x) => x.reset(this._opponentCharacters, this._playerCharacters));\n        this.allCharacters.forEach((character) => character.initialize());\n        this.turns.push(new Turn(0.1, null, this, [], [], \"Match Set Up\"));\n        this.allCharacters\n            .filter((char) => {\n            return char.events.some((x) => x.eventType === \"matchSetup\");\n        })\n            .forEach((character, index) => {\n            character.dispatchEvent(\"matchSetup\");\n        });\n        this.allCharacters\n            .filter((char) => {\n            return char.events.some((x) => x.eventType === \"matchStart\");\n        })\n            .sort((a, b) => {\n            if ((a.id === \"HANSOLO\" && b.id === \"HANSOLO\") ||\n                (a.id !== \"HANSOLO\" && b.id !== \"HANSOLO\")) {\n                if (a.stats.speed > b.stats.speed) {\n                    return 1;\n                }\n                else if (b.stats.speed > a.stats.speed) {\n                    return -1;\n                }\n                else {\n                    return (0,_characters_utils__WEBPACK_IMPORTED_MODULE_1__.randomNumber)(0, 1) === 0 ? 1 : -1;\n                }\n            }\n            else if (a.id === \"HANSOLO\") {\n                return 1;\n            }\n            else if (b.id === \"HANSOLO\") {\n                return -1;\n            }\n            return 0;\n        })\n            .forEach((char, index) => {\n            this.turns.push(new Turn(0.2, char, this, [], [], \"Start of Match\"));\n            char.dispatchEvent(\"matchStart\");\n        });\n        this.allCharacters.forEach((c) => c.dispatchEvent(\"endOfTurn\"));\n    }\n    nextTurn(turnNumber) {\n        const { character, tmAmount } = this.allCharacters.reduce((acc, char) => {\n            if (!char?.isDead) {\n                if (!acc.character) {\n                    acc.character = char;\n                }\n                else {\n                    const results = acc.character.compareTm(char);\n                    acc.character = results.character;\n                    acc.tmAmount = results.amount;\n                }\n            }\n            return acc;\n        }, { tmAmount: 0, character: null });\n        if (character !== null) {\n            this.allCharacters.forEach((char) => {\n                if (!char.isDead) {\n                    char.changeTurnMeter((tmAmount / character.stats.speed) * char.stats.speed);\n                }\n            });\n            this.turns.push(new Turn(turnNumber, character, this));\n            character.takeAction();\n            this.allCharacters.forEach((c) => c.dispatchEvent(\"endOfTurn\", { character }));\n        }\n    }\n    checkMatchEnd(currentRound, maxRounds) {\n        const playerLost = this._playerCharacters.every((x) => x.stats.health <= 0);\n        const opponentLost = this._opponentCharacters.every((x) => x.stats.health <= 0);\n        if (playerLost || opponentLost || currentRound > maxRounds) {\n            this.turns.push(new Turn(Infinity, null, this, [\n            // {\n            //   effects: {\n            //     winner: opponentLost\n            //       ? store.state.player.player?.name\n            //       : store.state.opponents.player?.name,\n            //   },\n            // },\n            ], [], \"Final Score\"));\n            if (playerLost) {\n                this._simulationData.opponentWins++;\n            }\n            else if (opponentLost) {\n                this._simulationData.playerWins++;\n            }\n            return true;\n        }\n        return false;\n    }\n    addLogs(logs, endOfTurn) {\n        if (this.turns.length <= 0) {\n            console.error(\"cannot add logs because there are no turns\");\n            return;\n        }\n        const currentTurn = this.turns[this.turns.length - 1];\n        if (Array.isArray(logs)) {\n            currentTurn.addLogs(logs, endOfTurn);\n        }\n        else {\n            currentTurn.addLogs([logs], endOfTurn);\n        }\n    }\n}\n// const gameEngine = new Engine();\n// export { gameEngine };\n\n\n//# sourceURL=webpack://swgoh/./src/types/gameEngine/gameEngine.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_lodash_lodash_js-node_modules_uuid_dist_esm-browser_v4_js"], () => (__webpack_require__("./src/pages/units/worker.ts")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"src_pages_units_worker_ts": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkswgoh"] = self["webpackChunkswgoh"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_lodash_lodash_js-node_modules_uuid_dist_esm-browser_v4_js").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;